<!DOCTYPE html>
<html>
<head>
	<title>SW Dice!</title>
	<style>
		html, body{
			margin: 0;
			padding: 0;
			border: 0;
			background-color: black;
			overflow: hidden;
			height: 100%;
		}
		canvas{
			width: 100%;
			height: 100%;
			background:transparent;
		}
		#webGLDiv{
			width: 100%;
			height: 100%;
			display: block;
			border: 0px solid black;
			position: absolute;
			top:0;
			bottom: 0;
			left: 0;
			right: 0;
			margin: 0;
			background-color: black;
		}
		#loading{
			position: absolute;
			top: 50%; left: 50%;
			transform: translate(-50%, -50%);
			display: none;
			font-size: 20pt;
			color: white;
			width: 100%;
			text-align: center;
		}
		option{
			font-size: 8pt !important;
		}
		select{
			font-size: 8pt !important;
		}
		input[type=color]{
			visibility: hidden;
			position: absolute;
			top: 0px;
			right: 0px;
		}
		.long-property-name{
			width: 100% !important;
		}
		.pickr{
			visibility: hidden;
		}
		.pcr-button{
			position: absolute !important;
			right: 50px;
			top: 0px;
		}
		.pcr-app{
			width: 196px !important;
		}
		.pcr-close-button{
			cursor: pointer;
			position: absolute;
			right: 1px;
			top: 1px;
			font-family: verdana;
			display: flex;
			justify-content: center;
			align-items: center;
			text-align: center;
			height: 1.2ex !important;
			padding: 0.3em 0em 0.4em;
			border-radius: 0px;
			margin: 0 !important;
			color: #75797e;
			background-color: #f1f3f4;
		}
		.pcr-close-button:hover{
			background-color: #ff4040;
			color: #f1f3f4
		}
	</style>

	<link rel="shortcut icon" href="../favicon.ico"><!--Generates website's favicon-->
	<link rel="icon" type="image/gif" href="../animated_favicon1.gif"><!--Generates website's animated favicon-->

	<script src="../JS/threeBundle.js"></script>
	<script src="../node_modules/three/examples/js/geometries/ParametricGeometries.js"></script>
	<script src="../node_modules/three/examples/js/geometries/TeapotBufferGeometry.js"></script>
	<script src="../node_modules/three/examples/js/exporters/GLTFExporter.js"></script>

	<script src="../JS/TrackballControls.js"></script>
	<script src="../JS/DragControls.js"></script>
	<script src="../JS/polyhedra.js"></script>
	<script src="../JS/mergedDualCubeData.js"></script>

	<script src="../node_modules/dat.gui/build/dat.gui.js"></script>
	<script type="text/javascript" src="../JS/stats.min.js"></script>

	<script src='../JS/threex.dilategeometry.js'></script>
	<script src='../JS/threex.atmospherematerial.js'></script>
	<script src="../JS/threex.geometricglowmesh.js"></script>
	<script src="../JS/threex.basiclighting.js"></script>

	<!--COLOR PICKER-->
	<link rel="stylesheet" href="../node_modules/@simonwep/pickr/dist/themes/monolith.min.css">
	<script type="text/javascript" src="../JS/pickr.js"></script>

	<!--SWEET ALERT-->
	<!--<script src="../JS/modernizr-custom.js"></script>-->
	<script src="../JS/sweetalert2.all.min.js"></script>
	<script>
//FUNDAMENTALS
		let scene = new THREE.Scene();
		let backgroundScene = new THREE.Scene();
		let renderer = new THREE.WebGLRenderer({preserveDrawingBuffer: true, antialias: false});
		let needsRedraw = false;

//GLOBAL VARIABLES
		let animateId;
		let webGLDiv;
		let loadingDiv;
		let divHeight;
		let divWidth;
		let camera;
		let backgroundCamera;
		let initialLights = {};
		let controls;
		let gui;
		let sierpinskiTetra;
		let menger;
		let heart;
		let teapot;
		let glowObject;
		let textures = {};
		let environments = {};
		let cubeMaps = {};
		let octahedronMaps = {};
		let dodecahedronMaps = {};
		let frameCount = 0;

//INITIAL SETUP
		let state = {
			objectType: "Boost",

			colors: {
				material: "#ff00ff",
				edges: "#ffff00",
				background: "#202124",
				innerGlow: "#8000ff",
				outerGlow: "#ff00ff",
			},

			rotate: false,
			rotateSpeed: {x: 0.006, y: 0.004, z: 0.002, f: 25, m: 2.5},
			demo: false,

			metalness: 1,
			roughness: 0.6,
			transparency: 0,
			side: THREE.DoubleSide,
			flatShading: true,
			reflectivity: 0.5,
			clearcoat: 0,
			clearcoatRoughness: 0,

			currentTexture: "None",
			currentEnvironment: "None",
			currentBackground: "None",
			envMapIntensity: 1,

			innerGlow: {coefficient: 0.6, power: 1.8},
			outerGlow: {coefficient: 0.1, power: 1.2},
			glow: false,

			visible: true,
			edgeHelper: false,

			lights: {},
			fixTorchPosition: false,
			torchOn: false,

			camera: {},
			maxDistance: 20,
			shadows: false,
		};

		let lights = {
			light1: new THREE.PointLight("#ffffff", 80, 0, 2),
			light2: new THREE.PointLight("#ffffff", 40, 0, 2),
			light3: new THREE.PointLight("#ffffff", 20, 0, 2),
			ambient: new THREE.AmbientLight("#ffffff", 0.6),
			torch: new THREE.PointLight("#ffffff", 5, 0, 0)
		};

		let mapList = ["None"];

		let stats = {
			object: new Stats(),
			on: false,
			enable: function(){
				stats.object.setMode(0);//0: fps, 1: ms, 2: mb

				stats.object.domElement.style.position = 'absolute';
				stats.object.domElement.style.left = '10px';
				stats.object.domElement.style.top = '0px';

				document.body.appendChild(stats.object.domElement);
			},
			disable: function(){
				document.body.removeChild(stats.object.domElement);
			}
		};

		let shapeList = ["Boost", "Setback", "Ability", "Difficulty", "Proficiency", "Challenge", "Force"];

		let diceColors = {
			Boost: "#90ffff",
			Setback: "#ffffff",//"#000000
			Ability: "#00b000",
			Difficulty: "#ffffff",//"#400080"
			Proficiency: "#ffff00",
			Challenge: "#ffffff",//"#c00000"
			Force: "#ffffff"
		};

//PIVOTS & OBJECTS
		let parent = new THREE.Object3D();
		scene.add(parent);

		let object1;

//MATERIALS
		let material = new THREE.MeshBasicMaterial({color: state.colors["material"], side: THREE.DoubleSide});
		let edgeMaterial = new THREE.LineBasicMaterial({color: state.colors["edges"], linewidth: 10});

		let metalMaterial = new THREE.MeshPhysicalMaterial({
			metalness: state.metalness,
			roughness: state.roughness,
			flatShading: state.flatShading,
			color: state.colors["material"],
			transparency: state.transparency,
			wireframe: false,
			transparent: true,
			side: state.side,
			reflectivity: state.reflectivity,
			envMapIntensity: state.envMapIntensity,
			clearcoat: state.clearcoat,
			clearcoatRoughness: state.clearcoatRoughness,
		});

		let backgroundMaterial = new THREE.MeshBasicMaterial({
			color: state.colors["background"],
			side: THREE.BackSide,
			depthTest: false,
			depthWrite: false,
		});

		let cubeMaterial = [];
		let octahedronMaterial = [];
		let dodecahedronMaterial = [];

		for(let i = 0; i < 6; i++){
			cubeMaterial.push(metalMaterial.clone());
		};

		for(let i = 0; i < 8; i++){
			octahedronMaterial.push(metalMaterial.clone());
		};

		for(let i = 0; i < 12; i++){
			dodecahedronMaterial.push(metalMaterial.clone());
		};

//LOADING MANAGER
		let manager = new THREE.LoadingManager();

		manager.onStart = function(url, itemsLoaded, itemsTotal){
			loadingDiv.style.display = "block";
			loadingDiv.innerHTML = 'Started loading file: ' + url + '.\nLoaded ' + itemsLoaded + ' of ' + itemsTotal + ' files.';
		};

		manager.onLoad = function(){
			loadingDiv.innerHTML = 'Loading complete!';
			loadingDiv.style.display = "none";
			needsRedraw = true;
		};

		manager.onProgress = function(url, itemsLoaded, itemsTotal){
			loadingDiv.innerHTML = 'Loading file: ' + url + '.\nLoaded ' + itemsLoaded + ' of ' + itemsTotal + ' files.';
		};

		manager.onError = function(url){
			loadingDiv.innerHTML = 'There was an error loading ' + url;
		};

//LOAD TEXTURES
		function flatten(string){
			return string.replace(/\s+/g, '').toLowerCase();
		};

		function loadMaps(){
			//TEXTURE LOADER
			let textureLoader = new THREE.TextureLoader(manager);
			textureLoader.setPath('../Images/SWDice/');

			let noImage = "../none.png";

			//LOAD BOOST MAPS
			cubeMaps["boost"] = [
				textureLoader.load(noImage), textureLoader.load(noImage),
				textureLoader.load('b4.png'), textureLoader.load('b5.png'),
				textureLoader.load('b3.png'), textureLoader.load('b6.png')
			];

			//LOAD SETBACK MAPS
			cubeMaps["setback"] = [
				textureLoader.load('s3.png'), textureLoader.load('s3.png'),
				textureLoader.load('s5.png'), textureLoader.load('s5.png'),
				textureLoader.load('s1.png'), textureLoader.load('s1.png')
			];

			//LOAD ABILITY MAPS
			octahedronMaps["ability"] = [
				textureLoader.load('a4.png'), textureLoader.load('a7.png'),
				textureLoader.load('a5.png'), textureLoader.load('a2.png'),
				textureLoader.load(noImage), textureLoader.load('a8.png'),
				textureLoader.load('a2.png'), textureLoader.load('a5.png')
			];

			//LOAD DIFFICULTY MAPS
			octahedronMaps["difficulty"] = [
				textureLoader.load('d4.png'), textureLoader.load('d2.png'),
				textureLoader.load('d4.png'), textureLoader.load('d3.png'),
				textureLoader.load('d1.png'), textureLoader.load('d7.png'),
				textureLoader.load('d4.png'), textureLoader.load('d8.png')
			];

			//LOAD PROFICIENCY MAPS
			dodecahedronMaps["proficiency"] = [
				textureLoader.load('a2.png'), textureLoader.load('p7.png'),
				textureLoader.load(noImage), textureLoader.load('p4.png'),
				textureLoader.load('p7.png'), textureLoader.load('p7.png'),
				textureLoader.load('p10.png'), textureLoader.load('p12.png'),
				textureLoader.load('a2.png'), textureLoader.load('p4.png'),
				textureLoader.load('p10.png'), textureLoader.load('a5.png')
			];

			//LOAD CHALLENGE MAPS
			dodecahedronMaps["challenge"] = [
				textureLoader.load('c2.png'), textureLoader.load('c8.png'),
				textureLoader.load('c1.png'), textureLoader.load('c4.png'),
				textureLoader.load('c8.png'), textureLoader.load('c6.png'),
				textureLoader.load('c10.png'), textureLoader.load('c12.png'),
				textureLoader.load('c2.png'), textureLoader.load('c4.png'),
				textureLoader.load('c10.png'), textureLoader.load('c6.png')
			];

			//LOAD FORCE MAPS
			dodecahedronMaps["force"] = [
				textureLoader.load('f1.png'), textureLoader.load('f10.png'),
				textureLoader.load('f8.png'), textureLoader.load('f1.png'),
				textureLoader.load('f1.png'), textureLoader.load('f1.png'),
				textureLoader.load('f8.png'), textureLoader.load('f10.png'),
				textureLoader.load('f1.png'), textureLoader.load('f7.png'),
				textureLoader.load('f1.png'), textureLoader.load('f10.png')
			];

			//ENVIRONMENT LOADER
			let loader = new THREE.CubeTextureLoader();
			loader.setPath('../Images/');

			for(const map of mapList){
				let mapName = flatten(map);

				switch(map){
					case "None":
						cubeMaps.none = [];

						environments.none = loader.load(['none.png', 'none.png', 'none.png',
							'none.png', 'none.png', 'none.png'
						]);
						break;
					default:
						let texture = textureLoader.load(map+'/'+mapName+'.png');
						texture.wrapS = THREE.RepeatWrapping;
						texture.wrapT = THREE.MirroredRepeatWrapping;

						textures[mapName] = texture;

						cubeMaps[mapName] = [
							textureLoader.load(map+'/px.png'), textureLoader.load(map+'/nx.png'),
							textureLoader.load(map+'/py.png'), textureLoader.load(map+'/ny.png'),
							textureLoader.load(map+'/pz.png'), textureLoader.load(map+'/nz.png')
						];

						environments[mapName] = loader.load([
							map+'/px.png', map+'/nx.png',
							map+'/py.png', map+'/ny.png',
							map+'/pz.png', map+'/nz.png'
						]);
						break;
				};
			};
		};

//SCENE
		function makeScene(){
			let geometry = new THREE.Geometry();

			object1 = new THREE.Mesh(geometry, metalMaterial);
			parent.add(object1);
			addGlow(object1);

			camera.position.set(0, 0, 4);
		};

		function makeBackground(){
			let backgroundGeometry = new THREE.SphereGeometry(2.2*state.maxDistance, 20, 20);
			mirrorUVs(backgroundGeometry);
			backgroundGeometry.rotateY(3*Math.PI / 2);

			backgroundScene.add(new THREE.Mesh(backgroundGeometry, backgroundMaterial));
		};

//ANIMATION
		function animate(){
			if(stats.on){
				stats.object.begin();
			};

			animateId = requestAnimationFrame(animate);
			controls.update();

			if(state.rotate){
				parent.rotation.x += state.rotateSpeed.x;
				parent.rotation.y += state.rotateSpeed.y;
				parent.rotation.z += state.rotateSpeed.z;
			};

			if(!state.fixTorchPosition && state.torchOn){
				lights.torch.position.copy(camera.position);
			};

			backgroundCamera = camera.clone();
			backgroundCamera.position.normalize().multiplyScalar(state.maxDistance);//set(0, 0, 0);
			//backgroundCamera.fov = 15;
			//backgroundCamera.zoom = 0.9;
			backgroundCamera.updateProjectionMatrix();

			renderer.clear();
			renderer.render(backgroundScene, backgroundCamera);
			renderer.render(scene, camera);

			if(state.demo){
				frameCount++;
				if(frameCount > 500){
					let rng = shapeList.indexOf(state.objectType) + 1;
					if(rng === shapeList.length){
						rng = 0;
					};
					/*let rng = Math.floor(Math.random() * 7);
					while(shapeList[rng] === state.objectType){
						rng = Math.floor(Math.random() * 7);
					};*/
					gui.objectSelect.setValue(shapeList[rng]);
					frameCount = 0;
				};
			};

			if(needsRedraw){
				draw(state.objectType);
				needsRedraw = false;
			};

			if(stats.on){
				stats.object.end();
			};
		};

//MOUSE & TOUCH
		function mouseControl(){
			controls = new THREE.TrackballControls(camera, renderer.domElement);
			controls.rotateSpeed = 5.0;
			controls.minDistance = 0.1;
			controls.maxDistance = state.maxDistance;
		};

//KEYBOARD
		function onDocumentKeyDown(event){
			let activeElementTag = document.activeElement.tagName;

			if(activeElementTag != "INPUT" && activeElementTag != "SELECT"){
				switch(event.which){
					case 27:
					//escape
						break;
					case 32:
					//spacebar
						document.getElementById("autoRotate").click();
						break;
					case 67:
					//c for console
						//console.log(gui.changeTextLine1)
						//camera.lookAt(camera.getWorldDirection(new THREE.Vector3(0, 0, 0)));
						//console.log(controls)
						//console.log(parent.rotation.y)
						//download(JSON.stringify(object1.geometry), "geo.txt", 'text/plain', "saveLink");
						//console.log(object1.geometry.vertices.length, object1.geometry.faces.length);
						//for(const face of object1.geometry.faces){
						//	console.log(face.materialIndex)
						//}
						//let geometry = new THREE.DodecahedronGeometry();
						//console.log(object1.material);
						break;
					case 69:
					//e for export
						//exportObject();
						break;
					case 83:
					//s for stats
						stats.on = !stats.on;
						if(stats.on){
							stats.enable();
						}
						else{
							stats.disable();
						};
						break;
				};
			};
		};

//LIGHTS
		function lighting(){
			//build lights
			for(const [name, light] of Object.entries(lights)){
				initialLights[name] = {color: '#'+light.color.getHexString(), intensity: light.intensity};
			};

			//Set light position
			lights.light1.position.setFromSphericalCoords(5, Math.PI / 4, -1*Math.PI / 3);
			lights.light2.position.setFromSphericalCoords(5, 3*Math.PI / 4, Math.PI / 3);
			lights.light3.position.setFromSphericalCoords(5, Math.PI / 2, Math.PI);

			//let lighting = new THREEx.ThreePointsLighting()

			//shadows
			if(state.shadows){
				lights.light1.castShadow = true;
				lights.light2.castShadow = true;
				lights.light3.castShadow = true;
				lights.torch.castShadow = true;
			};

			//add to the scene
			scene.add(lights.ambient);//ambient
			scene.add(lights.light1);
			scene.add(lights.light2);
			scene.add(lights.light3);
			//scene.add(lighting);
		};

//VECTOR OPERATIONS
		function midpoint2(points){
			let midpoint = new THREE.Vector2(0, 0, 0);

			for(const p of points){
				midpoint.add(p);
			};

			midpoint.multiplyScalar(1 / points.length);
			return midpoint;
		};

		function midpoint3(points){
			let midpoint = new THREE.Vector3(0, 0, 0);

			for(const p of points){
				midpoint.add(p);
			};

			midpoint.multiplyScalar(1 / points.length);
			return midpoint;
		};

		function rotateAtoB(A, B){
			let a = A.clone().normalize();
			let b = B.clone().normalize();
			let aDotb = a.dot(b);
			let aCrossb = new THREE.Vector3().crossVectors(a, b);
			let w = aCrossb.clone().normalize();
			let bRejecta = b.clone().sub(a.clone().multiplyScalar(aDotb)).normalize();
			let F = new THREE.Matrix3();
			let G = new THREE.Matrix3();
			let H = new THREE.Matrix3();
			let U = new THREE.Matrix3();

			if(aCrossb.equals(new THREE.Vector3(0, 0, 0))){
				return U;
			};

			H.set(
				a.x, bRejecta.x, -1*w.x,
				a.y, bRejecta.y, -1*w.y,
				a.z, bRejecta.z, -1*w.z
			);

			F.getInverse(H); 

			G.set(
				aDotb, -1*aCrossb.length(), 0,
				aCrossb.length(), aDotb, 0,
				0, 0, 1
			);

			U.getInverse(F).multiply(G).multiply(F);
			return U;
		};

//UV GENERATION & MANIPULATION
		function cloneUVs(UVArray){
			let clone = [];

			for(const faceUV of UVArray[0]){
				clone.push([faceUV[0].clone(), faceUV[1].clone(), faceUV[2].clone()]);
			};

			return [clone];
		};

		function assignSphericalUVs(geometry, fudge){
			let uvArray = [];
			let vertices = geometry.vertices;
			let tolerence = 0.1;
			let delta = 0.1

			function calculateSphericalUV(p){
				return new THREE.Vector2(0.5 + Math.atan2(p.x, p.z) / (2*Math.PI), 0.5 + Math.asin(p.y) / Math.PI);
			};

			for(const [i,face] of geometry.faces.entries()){
				let a = vertices[face.a].clone().normalize();
				let b = vertices[face.b].clone().normalize();
				let c = vertices[face.c].clone().normalize();
				let northPole = new THREE.Vector3(0, 1, 0);
				let southPole = new THREE.Vector3(0, -1, 0);
				let needsMoving;

				if(a.distanceTo(northPole) < delta || a.distanceTo(southPole) < delta){
					needsMoving = 'A';
				}
				else if(b.distanceTo(northPole) < delta || b.distanceTo(southPole) < delta){
					needsMoving = 'B';
				}
				else if(c.distanceTo(northPole) < delta || c.distanceTo(southPole) < delta){
					needsMoving = 'C';
				};

				let m = calculateSphericalUV(midpoint3([a, b, c]));
				let A = calculateSphericalUV(a);
				let B = calculateSphericalUV(b);
				let C = calculateSphericalUV(c);

				let M = midpoint2([A, B, C]);

				if(Math.abs(M.x - m.x) > tolerence){
					if(A.x <= M.x){
						A.x++;
					};

					if(B.x <= M.x){
						B.x++;
					};

					if(C.x <= M.x){
						C.x++;
					};
				};

				switch(needsMoving){
					case 'A':
						A.x = 0.5*(B.x + C.x);
						break;
					case 'B':
						B.x = 0.5*(A.x + C.x);
						break;
					case 'C':
						C.x = 0.5*(B.x + A.x);
						break;
					default:
						break;
				};

				uvArray.push([
					new THREE.Vector2(A.x, A.y),
					new THREE.Vector2(B.x, B.y),
					new THREE.Vector2(C.x, C.y)
				]);
			};

			geometry.faceVertexUvs[0] = uvArray;
			geometry.uvsNeedUpdate = true;
		};

		function insideOutUVs(geometry){
			//Moves baseline to middle of geometry
			let uvArray = [];

			for(const face of geometry.faceVertexUvs[0]){
				let a = face[0];
				let b = face[1];
				let c = face[2];

				if(a.y < 0.5 && b.y < 0.5 && c.y < 0.5){
					uvArray.push([new THREE.Vector2(a.x, a.y + 0.5), new THREE.Vector2(b.x, b.y + 0.5), new THREE.Vector2(c.x, c.y + 0.5)]);
				}
				else{
					uvArray.push([new THREE.Vector2(a.x, a.y - 0.5), new THREE.Vector2(b.x, b.y - 0.5), new THREE.Vector2(c.x, c.y - 0.5)]);
				}
			};

			geometry.faceVertexUvs[0] = uvArray;
			geometry.uvsNeedUpdate = true;
		};

		function rotateUVs(geometry){
			//Rotate uvs 90Â° clockwise
			let uvArray = [];

			for(const face of geometry.faceVertexUvs[0]){
				let a = face[0];
				let b = face[1];
				let c = face[2];

				uvArray.push([new THREE.Vector2(-a.y, a.x), new THREE.Vector2(-b.y, b.x), new THREE.Vector2(-c.y, c.x)]);
			};

			geometry.faceVertexUvs[0] = uvArray;
			geometry.uvsNeedUpdate = true;
		};

		function mirrorUVs(geometry){
			//Mirrors uvs left to right
			let uvArray = [];

			for(const face of geometry.faceVertexUvs[0]){
				let a = face[0];
				let b = face[1];
				let c = face[2];

				uvArray.push([new THREE.Vector2(1 - a.x, a.y), new THREE.Vector2(1 - b.x, b.y), new THREE.Vector2(1 - c.x, c.y)]);
			};

			geometry.faceVertexUvs[0] = uvArray;
			geometry.uvsNeedUpdate = true;
		};

		function octahedronUVs(geometry){
			let uvArray = [];

			for(const [i, f] of Object.entries(geometry.faces)){
				f.materialIndex = i;

				uvArray.push([
					new THREE.Vector2(0.5*Math.sin(2*Math.PI / 3)+0.5, 0.5*Math.cos(2*Math.PI / 3)+0.5),
					new THREE.Vector2(0.5, 1),
					new THREE.Vector2(0.5*Math.sin(4*Math.PI / 3)+0.5, 0.5*Math.cos(4*Math.PI / 3)+0.5)
				]);
			};

			geometry.faceVertexUvs[0] = uvArray;
			geometry.uvsNeedUpdate = true;
		};

		function dodecahedronUVs(geometry, radius){
			let uvArray = [];
			radius = radius || 1;

			for(let i = 0; i < 12; i++){
				geometry.faces[3*i].materialIndex = i;
				geometry.faces[3*i+1].materialIndex = i;
				geometry.faces[3*i+2].materialIndex = i;

				uvArray.push([
					new THREE.Vector2(0.5*radius*Math.sin(2*Math.PI / 5)+0.5, 0.5*radius*Math.cos(2*Math.PI / 5)+0.5),
					new THREE.Vector2(0.5*radius*Math.sin(4*Math.PI / 5)+0.5, 0.5*radius*Math.cos(4*Math.PI / 5)+0.5),
					new THREE.Vector2(0.5, 0.5*radius+0.5)
				]);

				uvArray.push([
					new THREE.Vector2(0.5*radius*Math.sin(4*Math.PI / 5)+0.5, 0.5*radius*Math.cos(4*Math.PI / 5)+0.5),
					new THREE.Vector2(0.5*radius*Math.sin(6*Math.PI / 5)+0.5, 0.5*radius*Math.cos(6*Math.PI / 5)+0.5),
					new THREE.Vector2(0.5, 0.5*radius+0.5)
				]);

				uvArray.push([
					new THREE.Vector2(0.5*radius*Math.sin(6*Math.PI / 5)+0.5, 0.5*radius*Math.cos(6*Math.PI / 5)+0.5),
					new THREE.Vector2(0.5*radius*Math.sin(8*Math.PI / 5)+0.5, 0.5*radius*Math.cos(8*Math.PI / 5)+0.5),
					new THREE.Vector2(0.5, 0.5*radius+0.5)
				]);
			};

			geometry.faceVertexUvs[0] = uvArray;
			geometry.uvsNeedUpdate = true;
		};

//GLOW MESH
		function glowMesh(mesh, insideDilation, outsideDilation, option){
			let glowMesh	= new THREEx.GeometricGlowMesh(mesh, insideDilation, outsideDilation, option);

			//inner glow parameters
			glowMesh.insideMesh.material.uniforms.glowColor.value.set(state.colors["innerGlow"]);
			glowMesh.insideMesh.material.uniforms.coeficient.value = state.innerGlow.coefficient;
			glowMesh.insideMesh.material.uniforms.power.value =  state.innerGlow.power;

			//inner glow parameters
			glowMesh.outsideMesh.material.uniforms.glowColor.value.set(state.colors["outerGlow"]);
			glowMesh.outsideMesh.material.uniforms.coeficient.value = state.outerGlow.coefficient;
			glowMesh.outsideMesh.material.uniforms.power.value = state.outerGlow.power;

			return glowMesh;
		};

		function addGlow(){
			object1.geometry.computeVertexNormals();
			glowObject = glowMesh(object1, 0.01, 0.1, "double");
			object1.add(glowObject.object3d);
		};

		function removeGlow(){
			object1.remove(glowObject.object3d);
		};

//ROUND EDGED SHAPES???
//https://discourse.threejs.org/t/round-edged-box/1402
		function createBoxWithRoundedEdges( width, height, depth, radius0, smoothness ) {
			let shape = new THREE.Shape();
			let eps = 0.00001;
			let radius = radius0 - eps;
			shape.absarc( eps, eps, eps, -Math.PI / 2, -Math.PI, true );
			shape.absarc( eps, height -  radius * 2, eps, Math.PI, Math.PI / 2, true );
			shape.absarc( width - radius * 2, height -  radius * 2, eps, Math.PI / 2, 0, true );
			shape.absarc( width - radius * 2, eps, eps, 0, -Math.PI / 2, true );
			let geometry = new THREE.ExtrudeBufferGeometry( shape, {
				depth: depth - radius0 * 2,
				bevelEnabled: true,
				bevelSegments: smoothness * 2,
				steps: 1,
				bevelSize: radius,
				bevelThickness: radius0,
				curveSegments: smoothness,
			});

			geometry.center();

			return geometry;
		};

		function roundedEdge(length, radius, segments){
			let shape = new THREE.Shape();

			shape.absarc(0, 0, radius, 0, Math.PI, false);
//			shape.absarc( eps, height -  radius * 2, eps, Math.PI, Math.PI / 2, true );
//			shape.absarc( width - radius * 2, height -  radius * 2, eps, Math.PI / 2, 0, true );
//			shape.absarc( width - radius * 2, eps, eps, 0, -Math.PI / 2, true );
			let geometry = new THREE.ExtrudeBufferGeometry( shape, {
				depth: length,
				bevelEnabled: true,
				bevelSegments: 3,
				steps: 0,
				bevelSize: 1,
				bevelThickness: 1,
				bevelOffset: 0,
			});

			geometry.center();

			return geometry;
		};

//SHAPE PICKER
		function draw(shape){
			removeGlow();
			renderer.renderLists.dispose();
			parent.remove(object1);

			//DRAW SHAPE
			switch(shape){
				case "Boost":
					object1 = new THREE.Mesh(new THREE.BoxGeometry(1.25, 1.25, 1.25), metalMaterial);
					object1.add(new THREE.Mesh(object1.geometry, cubeMaterial));
					//object1 = new THREE.Mesh(roundedEdge(2, 1, 3), cubeMaterial);
					//object1 = new THREE.Mesh(new THREE.SphereGeometry(2), metalMaterial);
					break;
				case "Setback":
					object1 = new THREE.Mesh(new THREE.BoxGeometry(1.25, 1.25, 1.25), cubeMaterial);
					break;
				case "Ability":
					object1 = new THREE.Mesh(new THREE.OctahedronGeometry(1), metalMaterial);
					object1.add(new THREE.Mesh(object1.geometry, octahedronMaterial));
					octahedronUVs(object1.geometry);
					break;
				case "Difficulty":
					object1 = new THREE.Mesh(new THREE.OctahedronGeometry(1), octahedronMaterial);
					octahedronUVs(object1.geometry);
					break;
				case "Proficiency":
					object1 = new THREE.Mesh(new THREE.DodecahedronGeometry(1), metalMaterial);
					object1.add(new THREE.Mesh(object1.geometry, dodecahedronMaterial));
					dodecahedronUVs(object1.geometry, 0.68);
					break;
				case "Challenge":
					object1 = new THREE.Mesh(new THREE.DodecahedronGeometry(1), dodecahedronMaterial);
					dodecahedronUVs(object1.geometry, 0.68);
					break;
				case "Force":
					object1 = new THREE.Mesh(new THREE.DodecahedronGeometry(1), metalMaterial);
					object1.add(new THREE.Mesh(object1.geometry, dodecahedronMaterial));
					dodecahedronUVs(object1.geometry, 0.68);
					break;
			};

			//SET ROTATION
			switch(shape){
				case "Boost":
				case "Setback":
					object1.rotateX(Math.PI / 8)
					object1.rotateY(Math.PI / 4);
					break;
				case "Proficiency":
				case "Challenge":
				case "Force":
					object1.rotateZ(-1*Math.PI / 2)
					object1.rotateY(Math.PI / 5);
					break;
			};

			//SET LIGHTING AND MATERIAL PROPERTIES
			switch(shape){
				case "Setback":
					gui.light1Intensity.setValue(200);
					gui.light2Intensity.setValue(100);
					gui.light3Intensity.setValue(50);
					gui.clearcoat.setValue(1);
					gui.clearcoatRoughness.setValue(0.5);
					break;
				case "Challenge":
					gui.clearcoat.setValue(1);
					gui.clearcoatRoughness.setValue(0.5);
					break;
				default:
					gui.light1Intensity.setValue(gui.light1Intensity.initialValue);
					gui.light2Intensity.setValue(gui.light2Intensity.initialValue);
					gui.light3Intensity.setValue(gui.light3Intensity.initialValue);
					gui.clearcoat.setValue(0);
					gui.clearcoatRoughness.setValue(0);
			};

			setTexture(shape);
			setColor("material", diceColors[shape]);

			if(state.edgeHelper){
				object1.add(new THREE.LineSegments(new THREE.EdgesGeometry(object1.geometry), edgeMaterial));
			};

			if(state.glow){
				addGlow()
			};

			parent.add(object1);
		};

//GUI
		gui = {
			parameters: {
				materialColor: function(){},//materialColor,
				materialR: hexToRGB(state.colors["material"]).r,
				materialG: hexToRGB(state.colors["material"]).g,
				materialB: hexToRGB(state.colors["material"]).b,
				transparency: state.transparency,
				edgeColor: function(){},
				backgroundColor: function(){},
				light1Intensity: lights.light1.intensity,
				light1Color: function(){},
				light2Intensity: lights.light2.intensity,
				light2Color: function(){},
				light3Intensity: lights.light3.intensity,
				light3Color: function(){},
				ambientIntensity: lights.ambient.intensity,
				ambientColor: function(){},
				torchIntensity: lights.torch.intensity,
				torchColor: function(){},
				useTorch: state.torchOn,
				metalness: state.metalness,
				roughness: state.roughness,
				reflectivity: state.reflectivity,
				envMapIntensity: state.envMapIntensity,
				clearcoat: state.clearcoat,
				clearcoatRoughness: state.clearcoatRoughness,
				flatShading: state.flatShading,
				edgeHelper: state.edgeHelper,
				rotate: state.rotate,
				rotateX: state.rotateSpeed.x*state.rotateSpeed.f,
				rotateY: state.rotateSpeed.y*state.rotateSpeed.f,
				rotateZ: state.rotateSpeed.z*state.rotateSpeed.f,
				demo: state.demo,
				fixTorch: state.fixTorchPosition,
				object: state.objectType,
				side: "Both",
				texture: state.currentTexture,
				environment: state.currentEnvironment,
				background: state.currentBackground,
				resetPosition: function(){},
				resetLights: function(){},
				screenshot: function(){},
				saveScene: function(){},
				loadScene: function(){},
				exportObject: function(){},
				innerGlowColor: function(){},
				outerGlowColor: function(){},
				innerGlowCoefficient: state.innerGlow.coefficient,
				innerGlowPower: state.innerGlow.power,
				outerGlowCoefficient: state.outerGlow.coefficient,
				outerGlowPower: state.outerGlow.power,
				glow: state.glow,
				glowOnly: !state.visible,
			},

			maxSwatches: 28,

			swatches: [
				'#ff0000',
				'#ff8000',
				'#ffff00',
				'#80ff00',
				'#00ff00',
				'#00ff80',
				'#00ffff',
				'#0080ff',
				'#0000ff',
				'#8000ff',
				'#ff00ff',
				'#ff0080',
				'#ffffff',
				'#000000',
				state.colors.background,
				'#8C7825',
				'#c0c0c0',
				'#885826',
				'#DE862B',
			],

			blurOnClose: false,
		};

		function makeGUI(){
			//COLOUR PICKER
			let pickr = new Pickr({
				el: document.getElementById("pickr"),
				theme: 'monolith',
				lockOpacity: true,
				closeOnScroll: true,
				comparison: true,
				closeWithKey: 'Enter',

				swatches: gui.swatches,

				components: {
					preview: true,
					opacity: true,
					hue: true,

					interaction: {
						hex: true,
						rgba: true,
						hsva: false,
						input: true,
						clear: false,
						save: false,
						cancel: false,
					},
				},
			});

			//Make pickr accessible
			gui.pickr = pickr;

			//Build pickr close button
			let closeButton = document.createElement("SPAN");
			closeButton.appendChild(document.createTextNode("\u00d7"));
			closeButton.classList.add("pcr-close-button");
			closeButton.addEventListener('click', () => pickr.hide());
			document.getElementsByClassName('pcr-app')[0].appendChild(closeButton);

			//Set max swatches
			gui.permanentSwatchesIndex = gui.swatches.length;

			function activatePickr(element){
				let selectColor = function(color, instance){
					setColor(element, color.toHEXA().toString());
				};

				let closePickr = function(){
					let newColor = pickr.getColor().toHEXA().toString().toLowerCase();
					let found = false;

					for(const color of gui.swatches){
						if(color.toLowerCase() == newColor){
							found = true;
							break;
						};
					};

					if(!found){
						gui.pickr.addSwatch(newColor);
						gui.swatches.push(newColor);
					};

					if(gui.swatches.length > gui.maxSwatches){
						gui.pickr.removeSwatch(gui.permanentSwatchesIndex);
						gui.swatches.splice(gui.permanentSwatchesIndex, 1);
					};

					pickr.off('change', selectColor);
					pickr.off('hide', closePickr);
					document.removeEventListener("keydown", cancelPickr);
				};

				let cancelPickr = function(event){
					if(event.which == 27){
						pickr.setColor(pickr._lastColor.toHEXA().toString());
						pickr.hide();
					};
				};

				pickr.setColor(document.getElementById(element+"ColorButton").style["background-color"]);
				pickr.on('change', selectColor);
				pickr.on('hide', closePickr);
				document.addEventListener("keydown", cancelPickr, {passive: true});
				document.getElementsByClassName('pcr-button')[0].click();
			};

			//GUI OBJECT
			gui.gui = new dat.GUI({autoPlace: true, width: 300, hideable: true});
			gui.gui.close();

			gui.objectSelect = gui.gui.add(gui.parameters, 'object', shapeList).name("Dice")
			.onChange(function(newValue){
				state.objectType = newValue;
				needsRedraw = true;
			});

			//BACKGROUND COLOR
			gui.color3 = gui.gui.add(gui.parameters, "backgroundColor").name("Background Colour")
			.onChange(function(){
				activatePickr("background");
			});
			gui.color3.domElement.parentElement.parentElement.id = "backgroundColorButton";

			//ROTATION FOLDER
			gui.fRotation = gui.gui.addFolder("Rotation");

			gui.resetPosition = gui.fRotation.add(gui.parameters, "resetPosition").name("Reset Position")
			.onChange(function(){
				controls.reset();
				parent.rotation.set(0, 0, 0);
			});

			gui.rotate = gui.fRotation.add(gui.parameters, "rotate").name("Auto Rotate")
			.onChange(function(newValue){
				state.rotate = newValue;
				document.getElementById("autoRotate").blur();
			});
			gui.rotate.domElement.childNodes[0].id = "autoRotate";

			gui.rotateX = gui.fRotation.add(gui.parameters, "rotateX").min(-1*state.rotateSpeed.m).max(state.rotateSpeed.m)
			.step(0.05).name("x")
			.onChange(function(newValue){
				state.rotateSpeed.x = newValue / state.rotateSpeed.f;
			});

			gui.rotateY = gui.fRotation.add(gui.parameters, "rotateY").min(-1*state.rotateSpeed.m).max(state.rotateSpeed.m)
			.step(0.05).name("y")
			.onChange(function(newValue){
				state.rotateSpeed.y = newValue / state.rotateSpeed.f;
			});

			gui.rotateZ = gui.fRotation.add(gui.parameters, "rotateZ").min(-1*state.rotateSpeed.m).max(state.rotateSpeed.m)
			.step(0.05).name("z")
			.onChange(function(newValue){
				state.rotateSpeed.z = newValue / state.rotateSpeed.f;
			});

			gui.demo = gui.fRotation.add(gui.parameters, "demo").name("Demo mode")
			.onChange(function(newValue){
				state.demo = newValue;
				gui.rotate.setValue(newValue);
				document.getElementById("demo").blur();
			});
			gui.demo.domElement.childNodes[0].id = "demo";

			//MATERIALS FOLDER
			gui.fMaterial = gui.gui.addFolder("Material");
			gui.fMaterial.domElement.parentElement.id = "fMaterial";
			//hide("fMaterial");

			gui.metalness = gui.fMaterial.add(gui.parameters, "metalness").min(0).max(1).step(0.01).name("Metalness")
			.onChange(function(newValue){
				state.metalness = newValue;
				applyToAllMaterials("metalness", newValue);
			});

			gui.roughness = gui.fMaterial.add(gui.parameters, "roughness").min(0).max(1).step(0.01).name("Roughness")
			.onChange(function(newValue){
				state.roughness = newValue;
				applyToAllMaterials("roughness", newValue);
			});

			gui.transparency = gui.fMaterial.add(gui.parameters, "transparency").min(0).max(1).step(0.1).name("Transparency")
			.onChange(function(newValue){
				state.transparency = newValue;
				applyToAllMaterials("transparency", newValue);
			});

			gui.side = gui.fMaterial.add(gui.parameters, 'side', ["Front", "Back", "Both"]).name("Side")
			.onChange(function(newValue){
				switch(newValue){
					case "Front":
						state.side = THREE.FrontSide;
						applyToAllMaterials("side", THREE.FrontSide);
						break;
					case "Back":
						state.side = THREE.BackSide;
						applyToAllMaterials("side", THREE.BackSide);
						break;
					case "Both":
						state.side = THREE.DoubleSide;
						applyToAllMaterials("side", THREE.DoubleSide);
						break;
				};
			});
			gui.side.domElement.parentElement.parentElement.id = "sideMaterial";
			hide("sideMaterial");

			gui.flatShading = gui.fMaterial.add(gui.parameters, "flatShading").name("Flat Shading")
			.onChange(function(newValue){
				state.flatShading = newValue;
				applyToAllMaterials("flatShading", newValue);
			});
			gui.flatShading.domElement.parentElement.parentElement.id = "flatShading";
			hide("flatShading");

			gui.reflectivity = gui.fMaterial.add(gui.parameters, "reflectivity").min(0).max(1).step(0.01).name("Reflectivity")
			.onChange(function(newValue){
				state.reflectivity = newValue;
				applyToAllMaterials("reflectivity", newValue);
			});

			gui.clearcoat = gui.fMaterial.add(gui.parameters, "clearcoat").min(0).max(1).step(0.01).name("Clearcoat")
			.onChange(function(newValue){
				state.clearcoat = newValue;
				applyToAllMaterials("clearcoat", newValue);
			});

			gui.clearcoatRoughness = gui.fMaterial.add(gui.parameters, "clearcoatRoughness").min(0).max(1).step(0.01).name("Clearcoat Roughness")
			.onChange(function(newValue){
				state.clearcoatRoughness = newValue;
				applyToAllMaterials("clearcoatRoughness", newValue);
			});

			gui.edgeHelper = gui.fMaterial.add(gui.parameters, "edgeHelper").name("Edge Helper")
			.onChange(function(newValue){
				state.edgeHelper = newValue;
				needsRedraw = true;
			});

			gui.color2 = gui.fMaterial.add(gui.parameters, "edgeColor").name("Edges")
			.onChange(function(){
				activatePickr("edges");
			});
			gui.color2.domElement.parentElement.parentElement.id = "edgesColorButton";

			//GLOW FOLDER
			gui.fGlow = gui.gui.addFolder("Glow Effects");
			gui.fGlow.domElement.parentElement.id = "fGlow";
			//hide("fGlow");

			gui.glowSelect = gui.fGlow.add(gui.parameters, "glow").name("Glow")
			.onChange(function(newValue){
				state.glow = newValue;
				if(state.glow){
					addGlow()
				}
				else{
					removeGlow();
					if(!state.visible){
						document.getElementById("glowOnly").click();
					};
				};
			});
			gui.glowSelect.domElement.id = "glowSelect";

			gui.color3 = gui.fGlow.add(gui.parameters, "innerGlowColor").name("Inner Glow")
			.onChange(function(){
				activatePickr("innerGlow");
			});
			gui.color3.domElement.parentElement.parentElement.id = "innerGlowColorButton";

			gui.innerGlowCoefficient = gui.fGlow.add(gui.parameters, "innerGlowCoefficient").min(0).max(2).step(0.1)
			.name("Coefficient")
			.onChange(function(newValue){
				glowObject.insideMesh.material.uniforms.coeficient.value = state.innerGlow.coefficient = newValue;
			});

			gui.innerGlowPower = gui.fGlow.add(gui.parameters, "innerGlowPower").min(0).max(5).step(0.1).name("Power")
			.onChange(function(newValue){
				glowObject.insideMesh.material.uniforms.power.value = state.innerGlow.power = newValue;
			});

			gui.color4 = gui.fGlow.add(gui.parameters, "outerGlowColor").name("Outer Glow")
			.onChange(function(){
				activatePickr("outerGlow");
			});
			gui.color4.domElement.parentElement.parentElement.id = "outerGlowColorButton";

			gui.outerGlowCoefficient = gui.fGlow.add(gui.parameters, "outerGlowCoefficient").min(0).max(2).step(0.1)
			.name("Coefficient")
			.onChange(function(newValue){
				glowObject.outsideMesh.material.uniforms.coeficient.value = state.outerGlow.coefficient = newValue;
			});

			gui.outerGlowPower = gui.fGlow.add(gui.parameters, "outerGlowPower").min(0).max(5).step(0.1).name("Power")
			.onChange(function(newValue){
				glowObject.outsideMesh.material.uniforms.power.value = state.outerGlow.power = newValue;
			});

			gui.glowOnly = gui.fGlow.add(gui.parameters, "glowOnly").name("Glow Only")
			.onChange(function(newValue){
				if(!state.glow){
					document.getElementById("glowSelect").click();
				};

				state.visible = !newValue;
				applyToAllMaterials("visible", state.visible);
			});
			gui.glowOnly.domElement.id = "glowOnly";

			//LOAD/SAVE FOLDER
			gui.fSave = gui.gui.addFolder("Load/Save");

			gui.exportObject = gui.fSave.add(gui.parameters, "exportObject").name("Export as GLTF Binary")
			.onChange(function(){
				exportObject();
			});

			gui.screenshot = gui.fSave.add(gui.parameters, "screenshot").name("Take Screenshot")
			.onChange(function(){
				screenshot();
			});

			//COLORS FOLDER
			gui.fColor = gui.gui.addFolder("Colours");
			gui.fColor.domElement.parentElement.id = "fColor";
			hide("fColor");

			gui.color1 = gui.fColor.add(gui.parameters, "materialColor").name("Object")
			.onChange(function(){
				activatePickr("material");
			});
			gui.color1.domElement.parentElement.parentElement.id = "materialColorButton";

			gui.materialR = gui.fColor.add(gui.parameters, "materialR").min(0).max(255).step(1).name("R")
			.onChange(function(newValue){
				setColor("material", '#' + twoDigitHex(newValue) + state.colors["material"].substring(3,7));
			});
			gui.materialR.domElement.childNodes[0].childNodes[0].id = "Rbox";
			gui.materialR.domElement.childNodes[1].childNodes[0].id = "Rslider";

			gui.materialG = gui.fColor.add(gui.parameters, "materialG").min(0).max(255).step(1).name("G")
			.onChange(function(newValue){
				setColor("material", state.colors["material"].substring(0,3) + twoDigitHex(newValue) + state.colors["material"].substring(5,7));
			});
			gui.materialG.domElement.childNodes[0].childNodes[0].id = "Gbox";
			gui.materialG.domElement.childNodes[1].childNodes[0].id = "Gslider";

			gui.materialB = gui.fColor.add(gui.parameters, "materialB").min(0).max(255).step(1).name("B")
			.onChange(function(newValue){
				setColor("material", state.colors["material"].substring(0,5) + twoDigitHex(newValue));
			});
			gui.materialB.domElement.childNodes[0].childNodes[0].id = "Bbox";
			gui.materialB.domElement.childNodes[1].childNodes[0].id = "Bslider";

			/*gui.color3 = gui.fColor.add(gui.parameters, "backgroundColor").name("Background")
			.onChange(function(){
				activatePickr("background");
			});
			gui.color3.domElement.parentElement.parentElement.id = "backgroundColorButton";*/

			//TEXTURES FOLDER
			gui.fTextures = gui.gui.addFolder("Textures");
			gui.fTextures.domElement.parentElement.id = "fTextures";
			hide("fTextures");

			gui.setTex = gui.fTextures.add(gui.parameters, 'texture', mapList).name("Texture")
			.onChange(function(newValue){setTexture(newValue)});

			gui.background = gui.fTextures.add(gui.parameters, 'background', mapList).name("Background")
			.onChange(function(newValue){setBackground(newValue)});

			gui.environment = gui.fTextures.add(gui.parameters, 'environment', mapList).name("Reflection")
			.onChange(function(newValue){setEnv(newValue)});

			gui.envMapIntensity = gui.fTextures.add(gui.parameters, "envMapIntensity").min(0).max(5).step(0.1).name("Reflection Intensity")
			.onChange(function(newValue){
				state.envMapIntensity = newValue;
				applyToAllMaterials("envMapIntensity", newValue);
			});

			//LIGHTS FOLDER
			gui.fLight = gui.gui.addFolder("Lights");
			gui.fLight.domElement.parentElement.id = "fLight";
			hide("fLight");

			gui.resetLights = gui.fLight.add(gui.parameters, "resetLights").name("Reset Lights")
			.onChange(function(){
				for(const [light, value] of Object.entries(lights)){
					setColor(light, initialLights[light].color);
				};

				gui.light1Intensity.setValue(gui.light1Intensity.initialValue);
				gui.light2Intensity.setValue(gui.light2Intensity.initialValue);
				gui.light3Intensity.setValue(gui.light3Intensity.initialValue);
				gui.ambientIntensity.setValue(gui.ambientIntensity.initialValue);
				gui.torchIntensity.setValue(gui.torchIntensity.initialValue);
			});

			//LIGHT1 SUBFOLDER
			gui.fLight1 = gui.fLight.addFolder("Light 1");

			gui.light1Color = gui.fLight1.add(gui.parameters, "light1Color").name("Color")
			.onChange(function(){
				activatePickr("light1");
			});
			gui.light1Color.domElement.parentElement.parentElement.id = "light1ColorButton";

			gui.light1Intensity = gui.fLight1.add(gui.parameters, "light1Intensity").min(0).max(200).step(5).name("Intensity")
			.onChange(function(newValue){
				lights.light1.intensity = newValue;
			});

			//LIGHT2 SUBFOLDER
			gui.fLight2 = gui.fLight.addFolder("Light 2");

			gui.light2Color = gui.fLight2.add(gui.parameters, "light2Color").name("Color")
			.onChange(function(){
				activatePickr("light2");
			});
			gui.light2Color.domElement.parentElement.parentElement.id = "light2ColorButton";

			gui.light2Intensity = gui.fLight2.add(gui.parameters, "light2Intensity").min(0).max(200).step(5).name("Intensity")
			.onChange(function(newValue){
				lights.light2.intensity = newValue;
			});

			//LIGHT3 SUBFOLDER
			gui.fLight3 = gui.fLight.addFolder("Light 3");

			gui.light3Color = gui.fLight3.add(gui.parameters, "light3Color").name("Color")
			.onChange(function(){
				activatePickr("light3");
			});
			gui.light3Color.domElement.parentElement.parentElement.id = "light3ColorButton";

			gui.light3Intensity = gui.fLight3.add(gui.parameters, "light3Intensity").min(0).max(200).step(5).name("Intensity")
			.onChange(function(newValue){
				lights.light3.intensity = newValue;
			});

			//AMBIENT LIGHT SUBFOLDER
			gui.fAmbient = gui.fLight.addFolder("Ambient");

			gui.ambientColor = gui.fAmbient.add(gui.parameters, "ambientColor").name("Color")
			.onChange(function(){
				activatePickr("ambient");
			});
			gui.ambientColor.domElement.parentElement.parentElement.id = "ambientColorButton";

			gui.ambientIntensity = gui.fAmbient.add(gui.parameters, "ambientIntensity").min(0).max(20).step(0.2).name("Intensity")
			.onChange(function(newValue){
				lights.ambient.intensity = newValue;
			});

			//TORCH LIGHT SUBFOLDER
			gui.fTorch = gui.fLight.addFolder("Torch");

			gui.useTorch = gui.fTorch.add(gui.parameters, "useTorch").name("Enable Torch")
			.onChange(function(newValue){
				state.torchOn = newValue;
				if(newValue){
					scene.add(lights.torch);
					scene.remove(lights.light1, lights.light2, lights.light3);
				}
				else{
					scene.remove(lights.torch);
					scene.add(lights.light1, lights.light2, lights.light3);
				};
			});

			gui.torchColor = gui.fTorch.add(gui.parameters, "torchColor").name("Color")
			.onChange(function(){
				activatePickr("torch");
			});
			gui.torchColor.domElement.parentElement.parentElement.id = "torchColorButton";

			gui.torchIntensity = gui.fTorch.add(gui.parameters, "torchIntensity").min(0).max(20).step(0.2).name("Intensity")
			.onChange(function(newValue){
				lights.torch.intensity = newValue;
			});

			gui.fixTorch = gui.fTorch.add(gui.parameters, "fixTorch").name("Fix Torch Position")
			.onChange(function(newValue){
				state.fixTorchPosition = newValue;
			});

			setupGUI();
		};

		function setupGUI(){
			let colorList = Object.entries(state.colors);
			for(const [name, color] of colorList){
				let current = document.getElementById(name + "ColorButton");
				current.style["background-color"] = color;
				current.style["border-right"] = "3px solid black";
				current.children[0].children[0].classList.add("long-property-name");
				state.colors["textured"+name] = color;
			};

			let lightList = Object.entries(lights);
			for(const [name, light] of lightList){
				let current = document.getElementById(name + "ColorButton");
				current.style["background-color"] = '#' + light.color.getHexString();
				current.style["border-right"] = "3px solid black";
			};

			//Blur focus on GUI close
			if(gui.blurOnClose){
				document.getElementsByClassName('close-button')[0].addEventListener('click', () =>
					document.activeElement.blur()
				);
			};

			//Enable Pickr color reset
			document.getElementsByClassName('pcr-last-color')[0].addEventListener('click', () =>
				gui.pickr.setColor(gui.pickr.getSelectedColor().toHEXA().toString())
			);
		};

//GUI FUNCTIONS
		function setEnv(env){
			state.currentEnvironment = env;
			env = flatten(env);

			applyToAllMaterials("envMap", environments[env]);
		};

		function setBackground(env){
			state.currentBackground = env;
			env = flatten(env);

			backgroundMaterial.map = textures[env];
			backgroundMaterial.needsUpdate = true;

			switch(env){
				case "none":
					if(state.colors["background"] != state.colors["texturedbackground"]){
						setColor("background", state.colors["texturedbackground"]);
					};
					break;
				default:
					setColor("background", "#ffffff", "texture");
			};
		};

		function setTexture(newValue){
			state.currentTexture = newValue;
			newtexture = flatten(newValue);

			metalMaterial.map = textures[newtexture];
			metalMaterial.needsUpdate = true;

			if(newtexture == "boost" || newtexture == "setback"){
				for(const [i, m] of Object.entries(cubeMaterial)){
					m.map = cubeMaps[newtexture][i];
					m.needsUpdate = true;
				};
			}
			else if(newtexture == "ability" || newtexture == "difficulty"){
				for(const [i, m] of Object.entries(octahedronMaterial)){
					m.map = octahedronMaps[newtexture][i];
					m.needsUpdate = true;
				};
			}
			else if(newtexture == "proficiency" || newtexture == "challenge" || newtexture == "force"){
				for(const [i, m] of Object.entries(dodecahedronMaterial)){
					m.map = dodecahedronMaps[newtexture][i];
					m.needsUpdate = true;
				};
			};
		};

		function setColor(element, newValue, option){
			switch(element){
				case "material":
					let rgb = hexToRGB(newValue);

					metalMaterial.color.set(newValue);

					for(const m of cubeMaterial){
						m.color.set(newValue);
					};

					for(const m of octahedronMaterial){
						m.color.set(newValue);
					};

					for(const m of dodecahedronMaterial){
						m.color.set(newValue);
					};

					document.getElementById("Rbox").value = rgb.r;
					document.getElementById("Rslider").style.width = (100 * rgb.r / 255).toString() + "%";
					document.getElementById("Gbox").value = rgb.g;
					document.getElementById("Gslider").style.width = (100 * rgb.g / 255).toString() + "%";
					document.getElementById("Bbox").value = rgb.b;
					document.getElementById("Bslider").style.width = (100 * rgb.b / 255).toString() + "%";
					break;
				case "background":
					backgroundMaterial.color.set(newValue);
					break;
				case "edges":
					edgeMaterial.color.set(newValue);
					break;
				case "innerGlow":
					glowObject.insideMesh.material.uniforms.glowColor.value.set(newValue);
					break;
				case "outerGlow":
					glowObject.outsideMesh.material.uniforms.glowColor.value.set(newValue);
					break;
				default:
					if(lights[element] != undefined){
						lights[element].color.set(newValue);
					}
					else{
						console.warn("Color " + element + " does not exist!");
						return null;
					};
			};

			state.colors[element] = document.getElementById(element+"ColorButton").style["background-color"] = newValue;

			if(option != "texture"){
				state.colors["textured"+element] = newValue;
			};
		};

		function hexToRGB(hexColor){
			let splitHex = {r: "0x" + hexColor.substring(1,3), g: "0x" + hexColor.substring(3,5), b: "0x" + hexColor.substring(5,7)};
			return {r: parseInt(splitHex.r), g: parseInt(splitHex.g), b: parseInt(splitHex.b)}
		};

		function twoDigitHex(number){
			if(number > 15){
				return number.toString(16);
			}
			else{
				return '0' + number.toString(16);
			};
		};

		function setShading(newValue){
			gui.flatShading.setValue(newValue);
		};

		function applyToAllMaterials(property, value){
			metalMaterial[property] = value;
			metalMaterial.needsUpdate = true;
			for(const m of cubeMaterial){
				m[property] = value;
				m.needsUpdate = true;
			};
			for(const m of octahedronMaterial){
				m[property] = value;
				m.needsUpdate = true;
			};
			for(const m of dodecahedronMaterial){
				m[property] = value;
				m.needsUpdate = true;
			};
		};

		function hide(element){
			document.getElementById(element).style.display = "none";
		};

		function show(element){
			document.getElementById(element).style.display = "block";
		};

//LOAD/SAVE FUNCTIONS
		function readJSONFile(evt){
			//Retrieve the first (and only!) File from the FileList object
			let file = evt.target.files[0]; 

			if(file){
				let reader = new FileReader();
				reader.onload = function(e){
					loadState(e);
				};
				reader.readAsText(file);
				document.getElementById('fileInput').value = "";//reset so onchange will be triggered on file reload
			}
			else{
				alert("Failed to load file!");
			};
		};

		function loadState(file){
			cancelAnimationFrame(animateId);
			controls.reset();

			let loadedState = JSON.parse(file.target.result);

			gui.objectSelect.setValue(loadedState.objectType);

			gui.rotate.setValue(loadedState.rotate);
			gui.rotateX.setValue(loadedState.rotateSpeed.x*loadedState.rotateSpeed.f);
			gui.rotateY.setValue(loadedState.rotateSpeed.y*loadedState.rotateSpeed.f);
			gui.rotateZ.setValue(loadedState.rotateSpeed.z*loadedState.rotateSpeed.f);

			gui.metalness.setValue(loadedState.metalness);
			gui.roughness.setValue(loadedState.roughness);
			gui.transparency.setValue(loadedState.transparency);
			gui.flatShading.setValue(loadedState.flatShading);
			gui.reflectivity.setValue(loadedState.reflectivity);
			gui.clearcoat.setValue(loadedState.clearcoat);
			gui.clearcoatRoughness.setValue(loadedState.clearcoatRoughness);
			switch(loadedState.side){
				case THREE.FrontSide:
					gui.side.setValue("Front");
					break;
				case THREE.BackSide:
					gui.side.setValue("Back");
					break;
				case THREE.DoubleSide:
					gui.side.setValue("Both");
					break;
			};

			gui.setTex.setValue(loadedState.currentTexture);
			gui.background.setValue(loadedState.currentBackground);
			gui.environment.setValue(loadedState.currentEnvironment);
			gui.envMapIntensity.setValue(loadedState.envMapIntensity);

			gui.light1Intensity.setValue(loadedState.lights.light1.intensity);
			gui.light2Intensity.setValue(loadedState.lights.light2.intensity);
			gui.light3Intensity.setValue(loadedState.lights.light3.intensity);
			gui.ambientIntensity.setValue(loadedState.lights.ambient.intensity);
			gui.torchIntensity.setValue(loadedState.lights.torch.intensity);
			gui.useTorch.setValue(loadedState.torchOn);
			gui.fixTorch.setValue(loadedState.fixTorchPosition);
			lights.torch.position.copy(loadedState.lights.torch.position);

			for(const [name, color] of Object.entries(loadedState.colors)){
				if(name.substr(0, 8) == "textured"){
					state.colors[name] = color;
				}
				else{
					setColor(name, color);
				};
			};

			for(const [name, light] of Object.entries(loadedState.lights)){
				setColor(name, light.color);
			};

			let loader = new THREE.ObjectLoader();
			camera.copy(loader.parse(JSON.parse(loadedState.camera.json)));
			parent.rotation.set(loadedState.currentRotation.x, loadedState.currentRotation.y, loadedState.currentRotation.z);

			resizeScreen();

			animate();
		};

		function saveState(){
			for(const [name, light] of Object.entries(lights)){
				state.lights[name] = {color: '#'+light.color.getHexString(), intensity: light.intensity};
			};
			state.lights.torch.position = lights.torch.position;

			state.camera.json = JSON.stringify(camera.toJSON());
			state.currentRotation = {x: parent.rotation.x, y: parent.rotation.y, z: parent.rotation.z};

			download(JSON.stringify(state), "scene.scn", 'text/plain', "saveLink");
		};

		function screenshot(){
			let elt = document.getElementById("saveLink");
			elt.href = renderer.domElement.toDataURL("image/png");
			elt.download = 'screenshot.png';
			elt.click();
			//let win = window.open();
			//document.write('<iframe src="' + renderer.domElement.toDataURL("image/png") + '" frameborder="0" style="margin: 0; padding: 0; border: 0; background-color: white; overflow: hidden; width:100%; height:100%; display:block; line-height: 0; position: absolute; left: 0; top: 0" allowfullscreen></iframe>');
		};

		function exportObject(){
			let exporter = new THREE.GLTFExporter();

			let bufferedObject = new THREE.Mesh(new THREE.BufferGeometry().fromGeometry(object1.geometry), object1.material);

			if(state.flatShading){
				bufferedObject.geometry.deleteAttribute("normal");
			};

			exporter.parse(bufferedObject, function(gltf){
				download(gltf, 'object.glb', 'text/plain', "saveLink");
			}, {binary: true, onlyVisible: true, forceIndices: true});
		};

//SETUP THE CANVAS
		function setCanvas(){
			webGLDiv = document.getElementById("webGLDiv");
			divHeight = webGLDiv.clientHeight;
			divWidth = webGLDiv.clientWidth;

			camera = new THREE.PerspectiveCamera(45, divWidth/ divHeight, 0.1, 1000);

			renderer.setSize(divWidth, divHeight);
			webGLDiv.appendChild(renderer.domElement);
			renderer.physicallyCorrectLights = true;
			renderer.autoClear = false;
		};

//DRAW THE SCENE ON THE CANVAS
		function go(){
			if(state.shadows){
				renderer.shadowMap.enabled = true;
			};

			makeBackground();
			makeScene();
			lighting();

			makeGUI();

			loadMaps();

			setEnv(state.currentEnvironment);
			setBackground(state.currentBackground);

			mouseControl();
			document.addEventListener("keydown", onDocumentKeyDown, {passive: true});
			webGLDiv.addEventListener('click', () => document.activeElement.blur(), {passive: true});
			fullscreenSetup();
			animate();
		};

//ON LOAD - MAKE IT SO!!!
		document.addEventListener("DOMContentLoaded", function(event){
			loadingDiv = document.getElementById("loading");
			document.getElementById('fileInput').addEventListener('change', readJSONFile, {passive: true});

			setCanvas();
			go();
		}, {passive: true});

//FULLSCREEN
		function fullscreenSetup(){
			let fullScreenChangeHandler = function(){
				if(document.webkitIsFullScreen || document.mozFullScreen || document.msFullscreenElement){
					state.fullscreen = true;
					gui.gui.hide();
					document.getElementById("jaznetLink").style.display = "none";
				}
				else{
					state.fullscreen = false;
					gui.gui.show();
					document.getElementById("jaznetLink").style.display = "block";
				};
			};

			let goFullscreen = function(){
				function launchIntoFullscreen(element){
					if(element.requestFullscreen){
						element.requestFullscreen();
					}
					else if(element.mozRequestFullScreen){
						element.mozRequestFullScreen();
					}
					else if(element.webkitRequestFullscreen){
						element.webkitRequestFullscreen();
					}
					else if(element.msRequestFullscreen){
						element.msRequestFullscreen();
					}
				};

				function exitFullscreen(){
					if(document.exitFullscreen){
						document.exitFullscreen();
					}
					else if(document.mozCancelFullScreen){
						document.mozCancelFullScreen();
					}
					else if(document.webkitExitFullscreen){
						document.webkitExitFullscreen();
					}
				};

				if(!state.fullscreen){
					launchIntoFullscreen(document.documentElement);
				}
				else{
					exitFullscreen();
				};
			};

			if(document.addEventListener){
				document.addEventListener('webkitfullscreenchange', fullScreenChangeHandler, false);
				document.addEventListener('mozfullscreenchange', fullScreenChangeHandler, false);
				document.addEventListener('fullscreenchange', fullScreenChangeHandler, false);
				document.addEventListener('MSFullscreenChange', fullScreenChangeHandler, false);
			};

			webGLDiv.addEventListener("dblclick", goFullscreen, {passive: true});
		};

//ON WINDOW RESIZE
		function resizeScreen(event){
			divHeight = webGLDiv.clientHeight;
			divWidth = webGLDiv.clientWidth;
			camera.aspect = divWidth/ divHeight;
			camera.updateProjectionMatrix();
			renderer.setSize(divWidth, divHeight);
		};

		window.addEventListener("resize", function(event){resizeScreen(event)}, {passive: true});

//DOWNLOAD
		function download(text, name, type, eltId){
			let elt = document.getElementById(eltId);
			let file = new Blob([text], {type: type});
			elt.href = URL.createObjectURL(file);
			elt.download = name;
			elt.click();
		};
	</script>
</head>

<body>
	<div id="webGLDiv"></div>

	<div id="pickr"></div>

	<div id="loading">
	</div>

	<a id="saveLink" style="display:none"></a>
	<input type="file" id="fileInput" accept=".scn" style="display:none"/>

	<div id="jaznetLink" style="position: absolute; bottom: 10px; right: 10px">
		<a href="../index.html">&lt;&lt; Back to Jaznet</a>
	</div>
</body>
</html>