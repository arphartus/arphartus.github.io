<!DOCTYPE html>
<html>
<head>
	<title>Lightsaber Fun!</title>
	<style>
		html, body{
			margin: 0;
			padding: 0;
			border: 0;
			background-color: black;
			overflow: hidden;
			height: 100%;
		}
		canvas{
			width: 100%;
			height: 100%;
			background:transparent;
		}
		#webGLDiv{
			width: 100%;
			height: 100%;
			display: block;
			border: 0px solid black;
			position: absolute;
			top:0;
			bottom: 0;
			left: 0;
			right: 0;
			margin: 0;
			background-color: black;
		}
		#loading{
			position: absolute;
			top: 50%; left: 50%;
			transform: translate(-50%, -50%);
			display: none;
			font-size: 20pt;
			color: white;
			width: 100%;
			text-align: center;
		}
	</style>

	<link rel="shortcut icon" href="../favicon.ico"><!--Generates website's favicon-->

	<script src="../JS/threeBundle.js"></script>
	<script src="../JS/GLTFExporter.js"></script>
	<script src="../JS/OBJExporter.js"></script>

	<script src="../JS/TrackballControls.js"></script>
	<script src="../JS/DragControls.js"></script>

	<script src="../dat.gui/build/dat.gui.js"></script>
	<script type="text/javascript" src="../JS/stats.min.js"></script>

	<script src='../JS/threex.dilategeometry.js'></script>
	<script src='../JS/threex.atmospherematerial.js'></script>
	<script src="../JS/threex.geometricglowmesh.js"></script>
	<script src="../JS/threex.basiclighting.js"></script>

	<script src="../JS/SimplexNoise.js"></script>
	<script src="../JS/LightningStrike.js"></script>
	<script src="../JS/LightningStorm.js"></script>

	<script src="../JS/indeterminateCheckbox.js"></script>

	<!--COLOR PICKER-->
	<link rel="stylesheet" href="../CSS/pickr.theme.monolith.min.css">
	<link rel="stylesheet" href="../CSS/Pickr1.css">
	<script type="text/javascript" src="../JS/pickr.js"></script>
	<script type="text/javascript" src="../JS/pickrAugments.js"></script>

	<!--SWEET ALERT-->
	<!--<script src="../JS/modernizr-custom.js"></script>-->
	<!--<script src="../JS/sweetalert2.all.min.js"></script>-->
	<script>
//FUNDAMENTALS
		let scene = new THREE.Scene();
		let backgroundScene = new THREE.Scene();
		let renderer = new THREE.WebGLRenderer({preserveDrawingBuffer: true, antialias: false});
		let needsRedraw = false;

//GLOBAL VARIABLES
		let animateId;
		let webGLDiv;
		let loadingDiv;
		let divHeight;
		let divWidth;
		let camera;
		let backgroundCamera;
		let initialLights = {};
		let controls;
		let gui;
		let glowObject;
		let textures = {};
		let environments = {};
		let cubeMaps = {};
		let octahedronMaps = {};
		let dodecahedronMaps = {};
		let frameCount = 0;

		let lightning = {
			object1: new THREE.Object3D(),
			strikes1: [],
			crossObject1: new THREE.Object3D(),
			crossStrikes1: [],
			object2: new THREE.Object3D(),
			strikes2: [],
			crossObject2: new THREE.Object3D(),
			crossStrikes2: [],
			maxStrikes: 3,
			maxCrossStrikes: 2,
			count: 0,
			radius: 0.075,
			straightness: 0.8,
			roughness: 0.95,
			ramification: 3,
			recursion: 1,
			recursionProbability: 0.1,
			up0: new THREE.Vector3(0, 1, 0),
			up1: new THREE.Vector3(0, -1, 0),
			onSubrayCreation: function(segment, parentSubray, childSubray, lightningStrike){
				lightningStrike.subrayCylinderPosition(segment, parentSubray, childSubray, 0, 0.0005, 0.00075);
			},
		};

		let pulse = {
			max: 1.25,
			min: 0.75,
			increment: 0.001,
		};

//INITIAL SETUP
		let state = {
			objectType: "Lightsaber 1",

			colors: {
				blade1: "#E66FFF",//#8000ff
				inner1: "#E996FF",//#6000c0
				outer1: "#D200FF",//#ff00ff
				blade2: "#FFA0A0",
				inner2: "#FF8080",
				outer2: "#ff0000",
				background: "#000000",
				//legacy, should be removed at some point
				material: "#ffffff",
				innerGlow: "#8000ff",
				outerGlow: "#ff00ff",
			},

			rotate: false,
			rotateSpeed: {x: 0.21, y: -0.2, z: 0.002, f: 25, m: 5},

			metalness: 0,
			roughness: 0.54,
			transparency: 0.05,
			transparent: true,
			side: THREE.FrontSide,
			flatShading: true,
			reflectivity: 0,
			clearcoat: 0,
			clearcoatRoughness: 0,
			emissiveIntensity: 1,

			currentTexture: "None",
			currentEnvironment: "None",
			currentBackground: "None",
			envMapIntensity: 1,

			innerGlow: {coefficient: 0.8, power: 0.8},
			outerGlow: {coefficient: 0.2, power: 2},
			glow: false,
			glowRadius: 0.1,

			visible: true,
			crossguard: true,
			ignited: true,
			lightning: false,
			lightningSpeed: 5,
			pulse: true,
			pulseSpeed: 3,
			pulseSpread: 7,
			saberlength: 4,

			lights: {},
			fixTorchPosition: false,
			torchOn: true,

			camera: {},
			maxDistance: 20,
			shadows: false,
		};

		let lights = {
			light1: new THREE.PointLight("#ffffff", 80, 0, 2),
			light2: new THREE.PointLight("#ffffff", 40, 0, 2),
			light3: new THREE.PointLight("#ffffff", 20, 0, 2),
			ambient: new THREE.AmbientLight("#ffffff", 0.6),
			torch: new THREE.PointLight("#ffffff", 1, 0, 0)
		};

		let mapList = ["None", "Pluto"];

		let stats = {
			object: new Stats(),
			on: false,
			enable: function(){
				stats.object.setMode(0);//0: fps, 1: ms, 2: mb

				stats.object.domElement.style.position = 'absolute';
				stats.object.domElement.style.left = '10px';
				stats.object.domElement.style.top = '0px';

				document.body.appendChild(stats.object.domElement);
			},
			disable: function(){
				document.body.removeChild(stats.object.domElement);
			}
		};

		let shapeList = ["Lightsaber 1", "Lightsaber 2", "Both Lightsabers"];

//PIVOTS & OBJECTS
		let parent = new THREE.Object3D();
		scene.add(parent);

		let object1;
		let object2;
		let crossguard1;
		let crossguard2;

//MATERIALS
		let material = new THREE.MeshBasicMaterial({color: state.colors["material"], side: THREE.FrontSide});

		let metalMaterial = new THREE.MeshPhysicalMaterial({
			metalness: state.metalness,
			roughness: state.roughness,
			flatShading: state.flatShading,
			color: state.colors["material"],
			transparency: state.transparency,
			wireframe: false,
			transparent: true,
			side: state.side,
			reflectivity: state.reflectivity,
			envMapIntensity: state.envMapIntensity,
			clearcoat: state.clearcoat,
			clearcoatRoughness: state.clearcoatRoughness,
		});

		let bladeMaterials = {
			blade1: new THREE.MeshPhysicalMaterial({
				metalness: state.metalness,
				roughness: state.roughness,
				flatShading: state.flatShading,
				color: state.colors["blade1"],
				emissive: state.colors["blade1"],
				emissiveIntensity: state.emissiveIntensity,
				transparency: state.transparency,
				wireframe: false,
				transparent: true,
				side: state.side,
				reflectivity: state.reflectivity,
				envMapIntensity: state.envMapIntensity,
				clearcoat: state.clearcoat,
				clearcoatRoughness: state.clearcoatRoughness,
			}),

			blade2: new THREE.MeshPhysicalMaterial({
				metalness: state.metalness,
				roughness: state.roughness,
				flatShading: state.flatShading,
				color: state.colors["blade2"],
				emissive: state.colors["blade2"],
				emissiveIntensity: state.emissiveIntensity,
				transparency: state.transparency,
				wireframe: false,
				transparent: true,
				side: state.side,
				reflectivity: state.reflectivity,
				envMapIntensity: state.envMapIntensity,
				clearcoat: state.clearcoat,
				clearcoatRoughness: state.clearcoatRoughness,
			}),

			lightning1: new THREE.MeshBasicMaterial({color: state.colors["outer1"]}),
			lightning2: new THREE.MeshBasicMaterial({color: state.colors["outer2"]}),
		};

		let hiltMaterial = new THREE.MeshPhysicalMaterial({
			metalness: 0.4,
			roughness: 0,
			flatShading: false,
			color: "#000000",
			transparency: 0,
			wireframe: false,
			transparent: false,
			side: THREE.DoubleSide,
			reflectivity: 1,
			envMapIntensity: 2.5,
			clearcoat: 0,
			clearcoatRoughness: 0,
		});

		let hiltTopMaterial = hiltMaterial.clone();
		hiltTopMaterial.visible = false;

		let backgroundMaterial = new THREE.MeshBasicMaterial({
			color: state.colors["background"],
			side: THREE.BackSide,
			depthTest: false,
			depthWrite: false,
		});

		let cubeMaterial = [];
		let octahedronMaterial = [];
		let dodecahedronMaterial = [];

		for(let i = 0; i < 6; i++){
			cubeMaterial.push(metalMaterial.clone());
		};

		for(let i = 0; i < 8; i++){
			octahedronMaterial.push(metalMaterial.clone());
		};

		for(let i = 0; i < 12; i++){
			dodecahedronMaterial.push(metalMaterial.clone());
		};

//LOADING MANAGER
		let manager = new THREE.LoadingManager();

		manager.onStart = function(url, itemsLoaded, itemsTotal){
			loadingDiv.style.display = "block";

			loadingDiv.innerHTML = 'Started loading file: ' + url + '.\nLoaded ' + itemsLoaded + ' of ' + itemsTotal + ' files.';
		};

		manager.onLoad = function(){
			buildObjects();
		};

		manager.onProgress = function(url, itemsLoaded, itemsTotal){
			loadingDiv.innerHTML = 'Loading file: ' + url + '.\nLoaded ' + itemsLoaded + ' of ' + itemsTotal + ' files.';
		};

		manager.onError = function(url){
			loadingDiv.innerHTML = 'There was an error loading ' + url;
		};

//LOAD TEXTURES
		function flatten(string){
			return string.replace(/\s+/g, '').toLowerCase();
		};

		function loadMaps(){
			//TEXTURE LOADER
			let textureLoader = new THREE.TextureLoader(manager);
			textureLoader.setPath('../Images/SWDice/');

			let noImage = "../none.png";

			//ENVIRONMENT LOADER
			let loader = new THREE.CubeTextureLoader(manager);
			loader.setPath('../Images/');

			for(const map of mapList){
				let mapName = flatten(map);

				switch(map){
					case "None":
						cubeMaps.none = [];

						environments.none = loader.load(['none.png', 'none.png', 'none.png',
							'none.png', 'none.png', 'none.png'
						]);
						break;
					default:
						environments[mapName] = loader.load([
							map+'/px.png', map+'/nx.png',
							map+'/py.png', map+'/ny.png',
							map+'/pz.png', map+'/nz.png'
						]);
						break;
				};
			};
		};

//SCENE
		function makeScene(){
			let geometry = new THREE.Geometry();

			object1 = new THREE.Mesh(geometry, metalMaterial);
			parent.add(object1);

			camera.position.set(0, 0, 4.5);
		};

		function makeBackground(){
			let backgroundGeometry = new THREE.SphereGeometry(2.2*state.maxDistance, 20, 20);
			//mirrorUVs(backgroundGeometry);
			backgroundGeometry.rotateY(3*Math.PI / 2);

			backgroundScene.add(new THREE.Mesh(backgroundGeometry, backgroundMaterial));
		};

//ANIMATION
		function animate(){
			if(stats.on){
				stats.object.begin();
			};

			animateId = requestAnimationFrame(animate);
			controls.update();

			if(state.rotate){
				parent.rotation.x += state.rotateSpeed.x;
				parent.rotation.y += state.rotateSpeed.y;
				parent.rotation.z += state.rotateSpeed.z;
			};

			if(!state.fixTorchPosition && state.torchOn){
				lights.torch.position.copy(camera.position);
			};

			backgroundCamera = camera.clone();
			backgroundCamera.position.normalize().multiplyScalar(state.maxDistance);//set(0, 0, 0);
			//backgroundCamera.fov = 15;
			//backgroundCamera.zoom = 0.9;
			backgroundCamera.updateProjectionMatrix();

			renderer.clear();
			renderer.render(backgroundScene, backgroundCamera);
			renderer.render(scene, camera);

			//Lightning effect
			if(state.lightning){
				if(state.lightningSpeed > 0 && lightning.count > 60 - 6*state.lightningSpeed){
					makeLightning(1);
					makeLightning(2);
					lightning.count = 0;
				};
				lightning.count++;
			};

			//Pulse effect
			if(state.pulse){
				let eI = bladeMaterials["blade1"].emissiveIntensity;

				eI += pulse.increment*state.pulseSpeed;
				if(eI >= 1 + 0.05*state.pulseSpread){
					pulse.increment *= -1;
				}
				else if(eI <= 1 - 0.05*state.pulseSpread){
					pulse.increment *= -1;
				};

				bladeMaterials["blade1"].emissiveIntensity = eI;
				bladeMaterials["blade2"].emissiveIntensity = eI;
			};

			if(needsRedraw){
				draw(state.objectType);
				needsRedraw = false;
			};

			if(stats.on){
				stats.object.end();
			};
		};

//MOUSE & TOUCH
		function mouseControl(){
			controls = new THREE.TrackballControls(camera, renderer.domElement);
			controls.rotateSpeed = 5.0;
			controls.minDistance = 0.1;
			controls.maxDistance = state.maxDistance;
		};

//KEYBOARD
		function onDocumentKeyDown(event){
			let activeElementTag = document.activeElement.tagName;

			if(activeElementTag != "INPUT" && activeElementTag != "SELECT"){
				switch(event.which){
					case 27:
					//escape
						break;
					case 32:
					//spacebar
						document.getElementById("autoRotate").click();
						break;
					case 37:
					//left arrow
						let prevShape = shapeList.indexOf(state.objectType) - 1;
						if(prevShape < 0){
							prevShape = shapeList.length - 1;
						};
						gui.objectSelect.setValue(shapeList[prevShape]);
						break;
					case 39:
					//right arrow
						let nextShape = shapeList.indexOf(state.objectType) + 1;
						if(nextShape === shapeList.length){
							nextShape = 0;
						};
						gui.objectSelect.setValue(shapeList[nextShape]);
						break;
					case 67:
					//c for console
						//console.log(gui.changeTextLine1)
						//camera.lookAt(camera.getWorldDirection(new THREE.Vector3(0, 0, 0)));
						//console.log(controls)
						//console.log(parent.rotation.y)
						//download(JSON.stringify(object1.geometry), "geo.txt", 'text/plain', "saveLink");
						console.log(object1.geometry.vertices.length, object1.geometry.faces.length);
						let geo = new THREE.CylinderGeometry(0.075, 0.1, 2.6, 4, 1, true);
						for(const face of geo.faces){
							console.log(face.materialIndex)
						}
						//let geometry = new THREE.DodecahedronGeometry();
						//console.log(object1.material);
						break;
					case 69:
					//e for export
						//exportObject();
						break;
					case 82:
						//r for reset
						controls.reset();
						parent.rotation.set(0, 0, 0);
						break;
					case 83:
					//s for stats
						stats.on = !stats.on;
						if(stats.on){
							stats.enable();
						}
						else{
							stats.disable();
						};
						break;
				};
			};
		};

//LIGHTS
		function lighting(){
			//build lights
			for(const [name, light] of Object.entries(lights)){
				initialLights[name] = {color: '#'+light.color.getHexString(), intensity: light.intensity};
			};

			//Set light position
			lights.light1.position.setFromSphericalCoords(5, Math.PI / 4, -1*Math.PI / 3);
			lights.light2.position.setFromSphericalCoords(5, 3*Math.PI / 4, Math.PI / 3);
			lights.light3.position.setFromSphericalCoords(5, Math.PI / 2, Math.PI);

			//let lighting = new THREEx.ThreePointsLighting()

			//shadows
			if(state.shadows){
				lights.light1.castShadow = true;
				lights.light2.castShadow = true;
				lights.light3.castShadow = true;
				lights.torch.castShadow = true;
			};

			//add to the scene
			scene.add(lights.ambient);//ambient
			//scene.add(lights.light1);
			//scene.add(lights.light2);
			//scene.add(lights.light3);
			scene.add(lights.torch);
			//scene.add(lighting);
		};

//VECTOR OPERATIONS
		function midpoint2(points){
			let midpoint = new THREE.Vector2(0, 0, 0);

			for(const p of points){
				midpoint.add(p);
			};

			midpoint.multiplyScalar(1 / points.length);
			return midpoint;
		};

		function midpoint3(points){
			let midpoint = new THREE.Vector3(0, 0, 0);

			for(const p of points){
				midpoint.add(p);
			};

			midpoint.multiplyScalar(1 / points.length);
			return midpoint;
		};

		function rotateAtoB(A, B){
			let a = A.clone().normalize();
			let b = B.clone().normalize();
			let aDotb = a.dot(b);
			let aCrossb = new THREE.Vector3().crossVectors(a, b);
			let w = aCrossb.clone().normalize();
			let bRejecta = b.clone().sub(a.clone().multiplyScalar(aDotb)).normalize();
			let F = new THREE.Matrix3();
			let G = new THREE.Matrix3();
			let H = new THREE.Matrix3();
			let U = new THREE.Matrix3();

			if(aCrossb.equals(new THREE.Vector3(0, 0, 0))){
				return U;
			};

			H.set(
				a.x, bRejecta.x, -1*w.x,
				a.y, bRejecta.y, -1*w.y,
				a.z, bRejecta.z, -1*w.z
			);

			F.getInverse(H); 

			G.set(
				aDotb, -1*aCrossb.length(), 0,
				aCrossb.length(), aDotb, 0,
				0, 0, 1
			);

			U.getInverse(F).multiply(G).multiply(F);
			return U;
		};

//LIGHTSABER OBJECT
		function buildLightsaber(objectNumber, length){
			let bladeMaterial = bladeMaterials["blade" + objectNumber];
			let geometry = new THREE.CylinderGeometry(0.075, 0.1, length, 64, 1, true);

			geometry.center();

			/*let taper  = new THREE.CylinderGeometry(0, 0.075, 0.2, 64, 1, true);
			taper.translate(0, 1.6, 0);
			geometry.merge(taper, new THREE.Matrix4(), 0);*/

			let tip = new THREE.SphereGeometry(0.075, 64, 64, 0, 2*Math.PI, 0, Math.PI / 2);
			tip.translate(0, 0.5*length, 0);
			geometry.merge(tip, new THREE.Matrix4(), 0);

			geometry.mergeVertices();
			geometry.computeVertexNormals();
			geometry.translate(0, 0.5, 0);

			let bladeObject = new THREE.Mesh(geometry, bladeMaterial);

			let glowMesh	= new THREEx.GeometricGlowMesh(bladeObject, 0.1*state.glowRadius, state.glowRadius);

			bladeMaterials["inner" + objectNumber] = glowMesh.insideMesh.material;
			bladeMaterials["outer" + objectNumber] = glowMesh.outsideMesh.material;
			setColor("inner" + objectNumber, state.colors["inner" + objectNumber]);
			setColor("outer" + objectNumber, state.colors["outer" + objectNumber]);

			//inner glow parameters
			glowMesh.insideMesh.material.uniforms.coeficient.value = state.innerGlow.coefficient;
			glowMesh.insideMesh.material.uniforms.power.value =  state.innerGlow.power;

			//outer glow parameters
			glowMesh.outsideMesh.material.uniforms.coeficient.value = state.outerGlow.coefficient;
			glowMesh.outsideMesh.material.uniforms.power.value = state.outerGlow.power;

			geometry.merge(glowMesh.insideMesh.geometry, new THREE.Matrix4(), 1);
			geometry.merge(glowMesh.outsideMesh.geometry, new THREE.Matrix4(), 2);

			let hilt = new THREE.CylinderGeometry(0.125, 0.125, 1, 64, 1, false);

			hilt.translate(0, -0.5*length, 0);

			geometry.merge(hilt, new THREE.Matrix4(), 3);

			let saberMaterial = [bladeMaterial, glowMesh.insideMesh.material, glowMesh.outsideMesh.material, hiltMaterial, hiltTopMaterial, hiltMaterial];

			return new THREE.Mesh(geometry, saberMaterial);
		};

		function buildCrossguard(objectNumber, length){
			let bladeMaterial = bladeMaterials["blade" + objectNumber];
			let geometry = new THREE.CylinderGeometry(0.06, 0.085, 0.6, 64, 1, true);

			geometry.center();

			let tip = new THREE.SphereGeometry(0.06, 64, 64, 0, 2*Math.PI, 0, Math.PI / 2);

			tip.translate(0, 0.3, 0);

			geometry.merge(tip, new THREE.Matrix4(), 0);
			geometry.mergeVertices();
			geometry.computeVertexNormals();
			geometry.translate(0, 0, 0);

			let bladeObject = new THREE.Mesh(geometry, bladeMaterial);

			let glowMesh	= new THREEx.GeometricGlowMesh(bladeObject, 0.075*state.glowRadius, 0.75*state.glowRadius);

			glowMesh.insideMesh.material = bladeMaterials["inner" + objectNumber];
			glowMesh.outsideMesh.material = bladeMaterials["outer" + objectNumber];

			geometry.merge(glowMesh.insideMesh.geometry, new THREE.Matrix4(), 1);
			geometry.merge(glowMesh.outsideMesh.geometry, new THREE.Matrix4(), 2);

			geometry.translate(0, 0.4, 0);

			let guard = geometry.clone();

			let hilt = new THREE.CylinderGeometry(0.11, 0.11, 0.4, 64, 1, false);

			guard.rotateX(Math.PI);

			geometry.merge(guard, new THREE.Matrix4(), 0);
			geometry.merge(hilt, new THREE.Matrix4(), 3);

			geometry.rotateZ(Math.PI / 2);
			geometry.translate(0, -0.5*length + 0.385, 0);

			let saberMaterial = [bladeMaterial, glowMesh.insideMesh.material, glowMesh.outsideMesh.material, hiltMaterial, hiltTopMaterial, hiltTopMaterial];

			return new THREE.Mesh(geometry, saberMaterial);
		};

//LIGHTNING EFFECT
		function makeLightning(objectNumber){
			let lightningObject = lightning["object" + objectNumber];
			let lightningCrossObject = lightning["crossObject" + objectNumber];
			let lightningMaterial = bladeMaterials["lightning" + objectNumber];
			let lightningStrikes = lightning["strikes" + objectNumber];
			let lightningCrossStrikes = lightning["crossStrikes" + objectNumber];

			let strike = new THREE.LightningStrike({
				sourceOffset: new THREE.Vector3(0.9*(Math.random() - 0.5), 2, 0.9*(Math.random() - 0.5)),
				destOffset: new THREE.Vector3(1.35*(Math.random() - 0.5), -1, 1.35*(Math.random() - 0.5)),
				radius0: lightning.radius,
				radius1: lightning.radius,
				straightness: lightning.straightness,
				roughness: lightning.roughness,
				ramification: lightning.ramification,
				recursion: lightning.recursion,
				recursionProbability: lightning.recursionProbability,
				up0: lightning.up0,
				up1: lightning.up1,
				onSubrayCreation: lightning.onSubrayCreation,
			});

			strike.scale(0.1, 1, 0.1);

			lightningStrikes.push(new THREE.Mesh(strike, lightningMaterial));
			lightningObject.add(lightningStrikes[lightningStrikes.length - 1]);
			if(lightningStrikes.length > lightning.maxStrikes){
				lightningObject.remove(lightningStrikes.shift());
			};

			let crossStrike = new THREE.LightningStrike({
				sourceOffset: new THREE.Vector3(-0.7, -11.15 + 1.08*(Math.random() - 0.5), 1.08*(Math.random() - 0.5)),
				destOffset: new THREE.Vector3(0.7, -11.15 + 1.08*(Math.random() - 0.5), 1.08*(Math.random() - 0.5)),
				radius0: lightning.radius,
				radius1: lightning.radius,
				straightness: 1.2*lightning.straightness,
				roughness: lightning.roughness,
				ramification: lightning.ramification,
				recursion: lightning.recursion,
				recursionProbability: lightning.recursionProbability,
				up0: lightning.up0,
				up1: lightning.up1,
				onSubrayCreation: lightning.onSubrayCreation,
			});

			crossStrike.scale(1, 0.1, 0.1);

			lightningCrossStrikes.push(new THREE.Mesh(crossStrike, lightningMaterial));
			lightningCrossObject.add(lightningCrossStrikes[lightningCrossStrikes.length - 1]);
			if(lightningCrossStrikes.length > lightning.maxCrossStrikes){
				lightningCrossObject.remove(lightningCrossStrikes.shift());
			};
		};

//SHAPE PICKER
		function draw(shape){
			renderer.renderLists.dispose();
			parent.remove(object1);
			parent.remove(object2);

			//DRAW SHAPE
			switch(shape){
				case "Lightsaber 1":
					parent.add(object1);
					break;
				case "Lightsaber 2":
					parent.add(object2);
					break;
				case "Both Lightsabers":
					parent.add(object1);
					parent.add(object2);
					break;
			};
		};

//GUI
		gui = {
			parameters: {
				materialColor: function(){},//materialColor,
				blade1Color: function(){},
				blade2Color: function(){},
				innerGlow1Color: function(){},
				outerGlow1Color: function(){},
				innerGlow2Color: function(){},
				outerGlow2Color: function(){},
				materialR: hexToRGB(state.colors["material"]).r,
				materialG: hexToRGB(state.colors["material"]).g,
				materialB: hexToRGB(state.colors["material"]).b,
				transparency: state.transparency,
				backgroundColor: function(){},
				light1Intensity: lights.light1.intensity,
				light1Color: function(){},
				light2Intensity: lights.light2.intensity,
				light2Color: function(){},
				light3Intensity: lights.light3.intensity,
				light3Color: function(){},
				ambientIntensity: lights.ambient.intensity,
				ambientColor: function(){},
				torchIntensity: lights.torch.intensity,
				torchColor: function(){},
				useTorch: state.torchOn,
				metalness: state.metalness,
				roughness: state.roughness,
				reflectivity: state.reflectivity,
				envMapIntensity: state.envMapIntensity,
				clearcoat: state.clearcoat,
				clearcoatRoughness: state.clearcoatRoughness,
				flatShading: state.flatShading,
				rotate: state.rotate,
				rotateX: state.rotateSpeed.x*state.rotateSpeed.f,
				rotateY: state.rotateSpeed.y*state.rotateSpeed.f,
				rotateZ: state.rotateSpeed.z*state.rotateSpeed.f,
				fixTorch: state.fixTorchPosition,
				object: state.objectType,
				side: "Front",
				texture: state.currentTexture,
				environment: state.currentEnvironment,
				background: state.currentBackground,
				resetPosition: function(){},
				resetLights: function(){},
				screenshot: function(){},
				saveScene: function(){},
				loadScene: function(){},
				exportObject: function(){},
				innerGlowColor: function(){},
				outerGlowColor: function(){},
				innerGlowCoefficient: state.innerGlow.coefficient,
				innerGlowPower: state.innerGlow.power,
				outerGlowCoefficient: state.outerGlow.coefficient,
				outerGlowPower: state.outerGlow.power,
				glow: state.glow,
				glowOnly: !state.visible,
				crossguard: state.crossguard,
				ignited: state.ignited,
				pulse: state.pulse,
				pulseSpeed: state.pulseSpeed,
				pulseSpread: state.pulseSpread,
				lightning: state.lightning,
				lightningSpeed: state.lightningSpeed,
				jaznet: function(){},
			},

			maxSwatches: 28,

			swatches: [
				'#ff0000',
				'#ff8000',
				'#ffff00',
				'#80ff00',
				'#00ff00',
				'#00ff80',
				'#00ffff',
				'#0080ff',
				'#0000ff',
				'#8000ff',
				'#ff00ff',
				'#ff0080',
				'#ffffff',
				'#000000',
				state.colors.blade1,
				state.colors.inner1,
				state.colors.outer1,
				state.colors.blade2,
				state.colors.inner2,
				state.colors.outer2,
			],

			blurOnClose: false,
		};

		function makeGUI(){
			//COLOUR PICKER
			let pickr = new Pickr({
				el: document.getElementById("pickr"),
				theme: 'monolith',
				lockOpacity: true,
				closeOnScroll: true,
				comparison: true,
				closeWithKey: 'Enter',

				swatches: gui.swatches,

				components: {
					preview: true,
					opacity: true,
					hue: true,

					interaction: {
						hex: true,
						rgba: true,
						hsva: false,
						input: true,
						clear: false,
						save: false,
						cancel: false,
					},
				},
			});

			//Make pickr accessible
			gui.pickr = pickr;

			//add close button and random button to pickr
			pickrAugments.addCloseButton(pickr);
			pickrAugments.addRandomColorButton(pickr);

			//Set max swatches
			gui.permanentSwatchesIndex = gui.swatches.length;

			function activatePickr(element){
				let selectColor = function(color, instance){
					setColor(element, color.toHEXA().toString());
				};

				let closePickr = function(){
					let newColor = pickr.getColor().toHEXA().toString().toLowerCase();
					let found = false;

					for(const color of gui.swatches){
						if(color.toLowerCase() == newColor){
							found = true;
							break;
						};
					};

					if(!found){
						gui.pickr.addSwatch(newColor);
						gui.swatches.push(newColor);
					};

					if(gui.swatches.length > gui.maxSwatches){
						gui.pickr.removeSwatch(gui.permanentSwatchesIndex);
						gui.swatches.splice(gui.permanentSwatchesIndex, 1);
					};

					pickr.off('change', selectColor);
					pickr.off('hide', closePickr);
					document.removeEventListener("keydown", cancelPickr);
				};

				let cancelPickr = function(event){
					if(event.which == 27){
						pickr.setColor(pickr._lastColor.toHEXA().toString());
						pickr.hide();
					};
				};

				pickr.setColor(document.getElementById(element+"ColorButton").style["background-color"]);
				pickr.on('change', selectColor);
				pickr.on('hide', closePickr);
				document.addEventListener("keydown", cancelPickr, {passive: true});
				document.getElementsByClassName('pcr-button')[0].click();
			};

			//GUI OBJECT
			gui.gui = new dat.GUI({autoPlace: true, width: 300, hideable: true});
			gui.gui.close();

			gui.objectSelect = gui.gui.add(gui.parameters, 'object', shapeList).name("Show")
			.onChange(function(newValue){
				state.objectType = newValue;
				needsRedraw = true;
			});

			gui.fOptions = gui.gui.addFolder("Visual Effects");
			gui.fOptions.domElement.parentElement.id = "fOptions";

			gui.ignited = gui.fOptions.add(gui.parameters, "ignited").name("Ignite").onChange(function(newValue){
				state.ignited = newValue;
				if(state.ignited){
					hiltTopMaterial.visible = false;
					for(const m of Object.values(bladeMaterials)){
						m.visible = true;
					};
				}
				else{
					hiltTopMaterial.visible = true;
					for(const m of Object.values(bladeMaterials)){
						m.visible = false;
					};
				};
				document.getElementById("ignited").blur();
			});
			gui.ignited.domElement.childNodes[0].id = "ignited";

			gui.crossguard = gui.fOptions.add(gui.parameters, "crossguard").name("Crossguard")
			.onChange(function(newValue){
				state.crossguard = newValue;
				if(state.crossguard){
					object1.add(crossguard1);
					object2.add(crossguard2);
				}
				else{
					object1.remove(crossguard1);
					object2.remove(crossguard2);
				};
				document.getElementById("crossguard").blur();
			});
			gui.crossguard.domElement.childNodes[0].id = "crossguard";

			gui.pulse = gui.fOptions.add(gui.parameters, "pulse").name("Pulse Effect").onChange(function(newValue){
				state.pulse = newValue;
				document.getElementById("pulse").blur();
			});
			gui.pulse.domElement.childNodes[0].id = "pulse";

			gui.pulseSpeed = gui.fOptions.add(gui.parameters, "pulseSpeed").min(1).max(10).step(1)
			.name("Pulse Speed")
			.onChange(function(newValue){
				state.pulseSpeed = newValue;
			});

			gui.pulseSpread = gui.fOptions.add(gui.parameters, "pulseSpread").min(1).max(10).step(1)
			.name("Pulse Range")
			.onChange(function(newValue){
				state.pulseSpread = newValue;
				if(bladeMaterials["blade1"].emissiveIntensity > 1 + 0.05*state.pulseSpread){
					bladeMaterials["blade1"].emissiveIntensity = 1 + 0.05*state.pulseSpread;
				}
				else if(bladeMaterials["blade1"].emissiveIntensity < 1 - 0.05*state.pulseSpread){
					bladeMaterials["blade1"].emissiveIntensity = 1 - 0.05*state.pulseSpread;
				};
			});

			gui.lightning = gui.fOptions.add(gui.parameters, "lightning").name("Electricity Effect")
			.onChange(function(newValue){
				state.lightning = newValue;
				if(state.lightning){
					object1.add(lightning["object1"]);
					crossguard1.add(lightning["crossObject1"]);
					object2.add(lightning["object2"]);
					crossguard2.add(lightning["crossObject2"]);
				}
				else{
					object1.remove(lightning["object1"]);
					crossguard1.remove(lightning["crossObject1"]);
					object2.remove(lightning["object2"]);
					crossguard2.remove(lightning["crossObject2"]);
				};
				document.getElementById("lightning").blur();
			});
			gui.lightning.domElement.childNodes[0].id = "lightning";

			gui.lightningSpeed = gui.fOptions.add(gui.parameters, "lightningSpeed").min(0).max(10).step(1)
			.name("Electricity Frequency")
			.onChange(function(newValue){
				state.lightningSpeed = newValue;
			});

			//COLORS FOLDER
			gui.fColor = gui.gui.addFolder("Colours");
			gui.fColor.domElement.parentElement.id = "fColor";

			gui.bladeColor1 = gui.fColor.add(gui.parameters, "blade1Color").name("Core 1")
			.onChange(function(){
				activatePickr("blade1");
			});
			gui.bladeColor1.domElement.parentElement.parentElement.id = "blade1ColorButton";

			gui.innerColor1 = gui.fColor.add(gui.parameters, "innerGlow1Color").name("Inner 1")
			.onChange(function(){
				activatePickr("inner1");
			});
			gui.innerColor1.domElement.parentElement.parentElement.id = "inner1ColorButton";

			gui.outerColor1 = gui.fColor.add(gui.parameters, "outerGlow1Color").name("Outer 1")
			.onChange(function(){
				activatePickr("outer1");
			});
			gui.outerColor1.domElement.parentElement.parentElement.id = "outer1ColorButton";

			gui.bladeColor2 = gui.fColor.add(gui.parameters, "blade2Color").name("Core 2")
			.onChange(function(){
				activatePickr("blade2");
			});
			gui.bladeColor2.domElement.parentElement.parentElement.id = "blade2ColorButton";

			gui.innerColor2 = gui.fColor.add(gui.parameters, "innerGlow2Color").name("Inner 2")
			.onChange(function(){
				activatePickr("inner2");
			});
			gui.innerColor2.domElement.parentElement.parentElement.id = "inner2ColorButton";

			gui.outerColor2 = gui.fColor.add(gui.parameters, "outerGlow2Color").name("Outer 2")
			.onChange(function(){
				activatePickr("outer2");
			});
			gui.outerColor2.domElement.parentElement.parentElement.id = "outer2ColorButton";

			gui.color3 = gui.fColor.add(gui.parameters, "backgroundColor").name("Background")
			.onChange(function(){
				activatePickr("background");
			});
			gui.color3.domElement.parentElement.parentElement.id = "backgroundColorButton";

			//MATERIALS FOLDER
			gui.fMaterial = gui.gui.addFolder("Material");
			gui.fMaterial.domElement.parentElement.id = "fMaterial";

			gui.metalness = gui.fMaterial.add(gui.parameters, "metalness").min(0).max(1).step(0.01).name("Metalness")
			.onChange(function(newValue){
				state.metalness = newValue;
				applyToAllMaterials("metalness", newValue);
			});

			gui.roughness = gui.fMaterial.add(gui.parameters, "roughness").min(0).max(1).step(0.01).name("Roughness")
			.onChange(function(newValue){
				state.roughness = newValue;
				applyToAllMaterials("roughness", newValue);
			});

			gui.transparency = gui.fMaterial.add(gui.parameters, "transparency").min(0).max(1).step(0.05).name("Transparency")
			.onChange(function(newValue){
				state.transparency = newValue;
				applyToAllMaterials("transparency", newValue);
			});

			gui.side = gui.fMaterial.add(gui.parameters, 'side', ["Front", "Back", "Both"]).name("Side")
			.onChange(function(newValue){
				switch(newValue){
					case "Front":
						state.side = THREE.FrontSide;
						applyToAllMaterials("side", THREE.FrontSide);
						break;
					case "Back":
						state.side = THREE.BackSide;
						applyToAllMaterials("side", THREE.BackSide);
						break;
					case "Both":
						state.side = THREE.DoubleSide;
						applyToAllMaterials("side", THREE.DoubleSide);
						break;
				};
			});
			gui.side.domElement.parentElement.parentElement.id = "sideMaterial";
			hide("sideMaterial");

			gui.flatShading = gui.fMaterial.add(gui.parameters, "flatShading").name("Flat Shading")
			.onChange(function(newValue){
				state.flatShading = newValue;
				applyToAllMaterials("flatShading", newValue);
			});
			gui.flatShading.domElement.parentElement.parentElement.id = "flatShading";
			hide("flatShading");

			gui.reflectivity = gui.fMaterial.add(gui.parameters, "reflectivity").min(0).max(1).step(0.01).name("Reflectivity")
			.onChange(function(newValue){
				state.reflectivity = newValue;
				applyToAllMaterials("reflectivity", newValue);
			});

			gui.clearcoat = gui.fMaterial.add(gui.parameters, "clearcoat").min(0).max(1).step(0.01).name("Clearcoat")
			.onChange(function(newValue){
				state.clearcoat = newValue;
				applyToAllMaterials("clearcoat", newValue);
			});

			gui.clearcoatRoughness = gui.fMaterial.add(gui.parameters, "clearcoatRoughness").min(0).max(1).step(0.01).name("Clearcoat Roughness")
			.onChange(function(newValue){
				state.clearcoatRoughness = newValue;
				applyToAllMaterials("clearcoatRoughness", newValue);
			});

			gui.innerGlowCoefficient = gui.fMaterial.add(gui.parameters, "innerGlowCoefficient").min(0).max(2).step(0.1)
			.name("Inner Coefficient")
			.onChange(function(newValue){
				bladeMaterials["inner1"].uniforms.coeficient.value = state.innerGlow.coefficient = newValue;
				bladeMaterials["inner2"].uniforms.coeficient.value = state.innerGlow.coefficient = newValue;
			});

			gui.innerGlowPower = gui.fMaterial.add(gui.parameters, "innerGlowPower").min(0).max(5).step(0.1).name("Inner Power")
			.onChange(function(newValue){
				bladeMaterials["inner1"].uniforms.power.value = state.innerGlow.power = newValue;
				bladeMaterials["inner2"].uniforms.power.value = state.innerGlow.power = newValue;
			});

			gui.innerGlowCoefficient = gui.fMaterial.add(gui.parameters, "outerGlowCoefficient").min(0).max(2).step(0.1)
			.name("Outer Coefficient")
			.onChange(function(newValue){
				bladeMaterials["outer1"].uniforms.coeficient.value = state.outerGlow.coefficient = newValue;
				bladeMaterials["outer2"].uniforms.coeficient.value = state.outerGlow.coefficient = newValue;
			});

			gui.innerGlowPower = gui.fMaterial.add(gui.parameters, "outerGlowPower").min(0).max(5).step(0.1).name("Outer Power")
			.onChange(function(newValue){
				bladeMaterials["outer1"].uniforms.power.value = state.outerGlow.power = newValue;
				bladeMaterials["outer2"].uniforms.power.value = state.outerGlow.power = newValue;
			});

			//ROTATION FOLDER
			gui.fRotation = gui.gui.addFolder("Rotation");

			gui.resetPosition = gui.fRotation.add(gui.parameters, "resetPosition").name("Reset Position")
			.onChange(function(){
				controls.reset();
				parent.rotation.set(0, 0, 0);
			});

			gui.rotate = gui.fRotation.add(gui.parameters, "rotate").name("Auto Rotate")
			.onChange(function(newValue){
				state.rotate = newValue;
				document.getElementById("autoRotate").blur();
			});
			gui.rotate.domElement.childNodes[0].id = "autoRotate";

			gui.rotateX = gui.fRotation.add(gui.parameters, "rotateX").min(-1*state.rotateSpeed.m).max(state.rotateSpeed.m)
			.step(0.05).name("x")
			.onChange(function(newValue){
				state.rotateSpeed.x = newValue / state.rotateSpeed.f;
			});

			gui.rotateY = gui.fRotation.add(gui.parameters, "rotateY").min(-1*state.rotateSpeed.m).max(state.rotateSpeed.m)
			.step(0.05).name("y")
			.onChange(function(newValue){
				state.rotateSpeed.y = newValue / state.rotateSpeed.f;
			});

			gui.rotateZ = gui.fRotation.add(gui.parameters, "rotateZ").min(-1*state.rotateSpeed.m).max(state.rotateSpeed.m)
			.step(0.05).name("z")
			.onChange(function(newValue){
				state.rotateSpeed.z = newValue / state.rotateSpeed.f;
			});

			//GLOW FOLDER
			gui.fGlow = gui.gui.addFolder("Glow Effects");
			gui.fGlow.domElement.parentElement.id = "fGlow";
			hide("fGlow");

			//I put it here to get it out of the way
			gui.color1 = gui.fGlow.add(gui.parameters, "materialColor").name("Object")
			.onChange(function(){
				activatePickr("material");
			});
			gui.color1.domElement.parentElement.parentElement.id = "materialColorButton";

			gui.glowSelect = gui.fGlow.add(gui.parameters, "glow").name("Glow")
			.onChange(function(newValue){
				state.glow = newValue;
				if(state.glow){
					addGlow()
				}
				else{
					removeGlow();
					if(!state.visible){
						document.getElementById("glowOnly").click();
					};
				};
			});
			gui.glowSelect.domElement.id = "glowSelect";

			gui.color3 = gui.fGlow.add(gui.parameters, "innerGlowColor").name("Inner Glow")
			.onChange(function(){
				activatePickr("innerGlow");
			});
			gui.color3.domElement.parentElement.parentElement.id = "innerGlowColorButton";

			gui.innerGlowCoefficient = gui.fGlow.add(gui.parameters, "innerGlowCoefficient").min(0).max(2).step(0.1)
			.name("Coefficient")
			.onChange(function(newValue){
				glowObject.insideMesh.material.uniforms.coeficient.value = state.innerGlow.coefficient = newValue;
			});

			gui.innerGlowPower = gui.fGlow.add(gui.parameters, "innerGlowPower").min(0).max(5).step(0.1).name("Power")
			.onChange(function(newValue){
				glowObject.insideMesh.material.uniforms.power.value = state.innerGlow.power = newValue;
			});

			gui.color4 = gui.fGlow.add(gui.parameters, "outerGlowColor").name("Outer Glow")
			.onChange(function(){
				activatePickr("outerGlow");
			});
			gui.color4.domElement.parentElement.parentElement.id = "outerGlowColorButton";

			gui.outerGlowCoefficient = gui.fGlow.add(gui.parameters, "outerGlowCoefficient").min(0).max(2).step(0.1)
			.name("Coefficient")
			.onChange(function(newValue){
				glowObject.outsideMesh.material.uniforms.coeficient.value = state.outerGlow.coefficient = newValue;
			});

			gui.outerGlowPower = gui.fGlow.add(gui.parameters, "outerGlowPower").min(0).max(5).step(0.1).name("Power")
			.onChange(function(newValue){
				glowObject.outsideMesh.material.uniforms.power.value = state.outerGlow.power = newValue;
			});

			gui.glowOnly = gui.fGlow.add(gui.parameters, "glowOnly").name("Glow Only")
			.onChange(function(newValue){
				if(!state.glow){
					document.getElementById("glowSelect").click();
				};

				state.visible = !newValue;
				applyToAllMaterials("visible", state.visible);
			});
			gui.glowOnly.domElement.id = "glowOnly";

			//LOAD/SAVE FOLDER
			gui.fSave = gui.gui.addFolder("Load/Save");

			gui.exportObject = gui.fSave.add(gui.parameters, "exportObject").name("Export as GLTF Binary")
			.onChange(function(){
				exportObject();
			});

			gui.screenshot = gui.fSave.add(gui.parameters, "screenshot").name("Take Screenshot")
			.onChange(function(){
				screenshot();
			});

			//TEXTURES FOLDER
			gui.fTextures = gui.gui.addFolder("Textures");
			gui.fTextures.domElement.parentElement.id = "fTextures";
			hide("fTextures");

			gui.setTex = gui.fTextures.add(gui.parameters, 'texture', mapList).name("Texture")
			.onChange(function(newValue){setTexture(newValue)});

			gui.background = gui.fTextures.add(gui.parameters, 'background', mapList).name("Background")
			.onChange(function(newValue){setBackground(newValue)});

			gui.environment = gui.fTextures.add(gui.parameters, 'environment', mapList).name("Reflection")
			.onChange(function(newValue){setEnv(newValue)});

			gui.envMapIntensity = gui.fTextures.add(gui.parameters, "envMapIntensity").min(0).max(5).step(0.1).name("Reflection Intensity")
			.onChange(function(newValue){
				state.envMapIntensity = newValue;
				applyToAllMaterials("envMapIntensity", newValue);
			});

			//LIGHTS FOLDER
			gui.fLight = gui.gui.addFolder("Lights");
			gui.fLight.domElement.parentElement.id = "fLight";
			hide("fLight");

			gui.resetLights = gui.fLight.add(gui.parameters, "resetLights").name("Reset Lights")
			.onChange(function(){
				for(const [light, value] of Object.entries(lights)){
					setColor(light, initialLights[light].color);
				};

				gui.light1Intensity.setValue(gui.light1Intensity.initialValue);
				gui.light2Intensity.setValue(gui.light2Intensity.initialValue);
				gui.light3Intensity.setValue(gui.light3Intensity.initialValue);
				gui.ambientIntensity.setValue(gui.ambientIntensity.initialValue);
				gui.torchIntensity.setValue(gui.torchIntensity.initialValue);
			});

			//LIGHT1 SUBFOLDER
			gui.fLight1 = gui.fLight.addFolder("Light 1");

			gui.light1Color = gui.fLight1.add(gui.parameters, "light1Color").name("Color")
			.onChange(function(){
				activatePickr("light1");
			});
			gui.light1Color.domElement.parentElement.parentElement.id = "light1ColorButton";

			gui.light1Intensity = gui.fLight1.add(gui.parameters, "light1Intensity").min(0).max(200).step(5).name("Intensity")
			.onChange(function(newValue){
				lights.light1.intensity = newValue;
			});

			//LIGHT2 SUBFOLDER
			gui.fLight2 = gui.fLight.addFolder("Light 2");

			gui.light2Color = gui.fLight2.add(gui.parameters, "light2Color").name("Color")
			.onChange(function(){
				activatePickr("light2");
			});
			gui.light2Color.domElement.parentElement.parentElement.id = "light2ColorButton";

			gui.light2Intensity = gui.fLight2.add(gui.parameters, "light2Intensity").min(0).max(200).step(5).name("Intensity")
			.onChange(function(newValue){
				lights.light2.intensity = newValue;
			});

			//LIGHT3 SUBFOLDER
			gui.fLight3 = gui.fLight.addFolder("Light 3");

			gui.light3Color = gui.fLight3.add(gui.parameters, "light3Color").name("Color")
			.onChange(function(){
				activatePickr("light3");
			});
			gui.light3Color.domElement.parentElement.parentElement.id = "light3ColorButton";

			gui.light3Intensity = gui.fLight3.add(gui.parameters, "light3Intensity").min(0).max(200).step(5).name("Intensity")
			.onChange(function(newValue){
				lights.light3.intensity = newValue;
			});

			//AMBIENT LIGHT SUBFOLDER
			gui.fAmbient = gui.fLight.addFolder("Ambient");

			gui.ambientColor = gui.fAmbient.add(gui.parameters, "ambientColor").name("Color")
			.onChange(function(){
				activatePickr("ambient");
			});
			gui.ambientColor.domElement.parentElement.parentElement.id = "ambientColorButton";

			gui.ambientIntensity = gui.fAmbient.add(gui.parameters, "ambientIntensity").min(0).max(20).step(0.2).name("Intensity")
			.onChange(function(newValue){
				lights.ambient.intensity = newValue;
			});

			//TORCH LIGHT SUBFOLDER
			gui.fTorch = gui.fLight.addFolder("Torch");

			gui.useTorch = gui.fTorch.add(gui.parameters, "useTorch").name("Enable Torch")
			.onChange(function(newValue){
				state.torchOn = newValue;
				if(newValue){
					scene.add(lights.torch);
					scene.remove(lights.light1, lights.light2, lights.light3);
				}
				else{
					scene.remove(lights.torch);
					scene.add(lights.light1, lights.light2, lights.light3);
				};
			});
			gui.useTorch.domElement.childNodes[0].id = "useTorch";

			gui.torchColor = gui.fTorch.add(gui.parameters, "torchColor").name("Color")
			.onChange(function(){
				activatePickr("torch");
			});
			gui.torchColor.domElement.parentElement.parentElement.id = "torchColorButton";

			gui.torchIntensity = gui.fTorch.add(gui.parameters, "torchIntensity").min(0).max(20).step(0.2).name("Intensity")
			.onChange(function(newValue){
				lights.torch.intensity = newValue;
			});

			gui.fixTorch = gui.fTorch.add(gui.parameters, "fixTorch").name("Fix Torch Position")
			.onChange(function(newValue){
				state.fixTorchPosition = newValue;
			});

			gui.jaznet = gui.gui.add(gui.parameters, "jaznet").name(" << Back to Jaznet")
			.onChange(function(){
				document.getElementById("jaznet").click();
			});

			setupGUI();
		};

		function setupGUI(){
			let colorList = Object.entries(state.colors);
			for(const [name, color] of colorList){
				let current = document.getElementById(name + "ColorButton");
				current.style["background-color"] = color;
				current.style["border-right"] = "3px solid black";
				current.children[0].children[0].classList.add("long-property-name");
				state.colors["textured"+name] = color;
			};

			let lightList = Object.entries(lights);
			for(const [name, light] of lightList){
				let current = document.getElementById(name + "ColorButton");
				current.style["background-color"] = '#' + light.color.getHexString();
				current.style["border-right"] = "3px solid black";
			};

			//Blur focus on GUI close
			if(gui.blurOnClose){
				document.getElementsByClassName('close-button')[0].addEventListener('click', () =>
					document.activeElement.blur()
				);
			};

			//Enable Pickr color reset
			document.getElementsByClassName('pcr-last-color')[0].addEventListener('click', () =>
				gui.pickr.setColor(gui.pickr.getSelectedColor().toHEXA().toString())
			);
		};

//GUI FUNCTIONS
		function setEnv(env){
			state.currentEnvironment = env;
			env = flatten(env);

			applyToAllMaterials("envMap", environments[env]);
		};

		function setBackground(env){
			state.currentBackground = env;
			env = flatten(env);

			backgroundMaterial.map = textures[env];
			backgroundMaterial.needsUpdate = true;

			switch(env){
				case "none":
					if(state.colors["background"] != state.colors["texturedbackground"]){
						setColor("background", state.colors["texturedbackground"]);
					};
					break;
				default:
					setColor("background", "#ffffff", "texture");
			};
		};

		function setTexture(newValue){
			state.currentTexture = newValue;
			newtexture = flatten(newValue);

			metalMaterial.map = textures[newtexture];
			metalMaterial.needsUpdate = true;

			if(newtexture == "boost" || newtexture == "setback"){
				for(const [i, m] of Object.entries(cubeMaterial)){
					m.map = cubeMaps[newtexture][i];
					m.needsUpdate = true;
				};
			}
			else if(newtexture == "ability" || newtexture == "difficulty"){
				for(const [i, m] of Object.entries(octahedronMaterial)){
					m.map = octahedronMaps[newtexture][i];
					m.needsUpdate = true;
				};
			}
			else if(newtexture == "proficiency" || newtexture == "challenge" || newtexture == "force"){
				for(const [i, m] of Object.entries(dodecahedronMaterial)){
					m.map = dodecahedronMaps[newtexture][i];
					m.needsUpdate = true;
				};
			};
		};

		function setColor(element, newValue, option){
			switch(element){
				case "material":
					let rgb = hexToRGB(newValue);

					metalMaterial.color.set(newValue);

					for(const m of cubeMaterial){
						m.color.set(newValue);
					};

					for(const m of octahedronMaterial){
						m.color.set(newValue);
					};

					for(const m of dodecahedronMaterial){
						m.color.set(newValue);
					};

					document.getElementById("Rbox").value = rgb.r;
					document.getElementById("Rslider").style.width = (100 * rgb.r / 255).toString() + "%";
					document.getElementById("Gbox").value = rgb.g;
					document.getElementById("Gslider").style.width = (100 * rgb.g / 255).toString() + "%";
					document.getElementById("Bbox").value = rgb.b;
					document.getElementById("Bslider").style.width = (100 * rgb.b / 255).toString() + "%";
					break;
				case "blade1":
					bladeMaterials["blade1"].color.set(newValue);
					bladeMaterials["blade1"].emissive.set(newValue);
					break;
				case "blade2":
					bladeMaterials["blade2"].color.set(newValue);
					bladeMaterials["blade2"].emissive.set(newValue);
					break;
				case "inner1":
					bladeMaterials["inner1"].uniforms.glowColor.value.set(newValue);
					break;
				case "inner2":
					bladeMaterials["inner2"].uniforms.glowColor.value.set(newValue);
					break;
				case "outer1":
					bladeMaterials["outer1"].uniforms.glowColor.value.set(newValue);
					bladeMaterials["lightning1"].color.set(newValue);
					break;
				case "outer2":
					bladeMaterials["outer2"].uniforms.glowColor.value.set(newValue);
					bladeMaterials["lightning2"].color.set(newValue);
					break;
				case "lightning1":
					bladeMaterials["lightning1"].color.set(newValue);
					break;
				case "lightning2":
					bladeMaterials["lightning2"].color.set(newValue);
					break;
				case "background":
					backgroundMaterial.color.set(newValue);
					break;
				case "innerGlow":
					glowObject.insideMesh.material.uniforms.glowColor.value.set(newValue);
					break;
				case "outerGlow":
					glowObject.outsideMesh.material.uniforms.glowColor.value.set(newValue);
					break;
				default:
					if(typeof lights[element] !== "undefined"){
						lights[element].color.set(newValue);
					}
					else{
						console.warn("Color " + element + " does not exist!");
						return null;
					};
			};

			state.colors[element] = document.getElementById(element+"ColorButton").style["background-color"] = newValue;

			if(option != "texture"){
				state.colors["textured"+element] = newValue;
			};
		};

		function hexToRGB(hexColor){
			let splitHex = {r: "0x" + hexColor.substring(1,3), g: "0x" + hexColor.substring(3,5), b: "0x" + hexColor.substring(5,7)};
			return {r: parseInt(splitHex.r), g: parseInt(splitHex.g), b: parseInt(splitHex.b)}
		};

		function twoDigitHex(number){
			if(number > 15){
				return number.toString(16);
			}
			else{
				return '0' + number.toString(16);
			};
		};

		function setShading(newValue){
			gui.flatShading.setValue(newValue);
		};

		function applyToAllMaterials(property, value){
			metalMaterial[property] = value;
			metalMaterial.needsUpdate = true;
			bladeMaterials["blade1"][property] = value;
			bladeMaterials["blade1"].needsUpdate = true;
			bladeMaterials["blade2"][property] = value;
			bladeMaterials["blade2"].needsUpdate = true;
		};

		function hide(element){
			document.getElementById(element).style.display = "none";
		};

		function show(element){
			document.getElementById(element).style.display = "block";
		};

//LOAD/SAVE FUNCTIONS
		function readJSONFile(evt){
			//Retrieve the first (and only!) File from the FileList object
			let file = evt.target.files[0]; 

			if(file){
				let reader = new FileReader();
				reader.onload = function(e){
					loadState(e);
				};
				reader.readAsText(file);
				document.getElementById('fileInput').value = "";//reset so onchange will be triggered on file reload
			}
			else{
				alert("Failed to load file!");
			};
		};

		function loadState(file){
			cancelAnimationFrame(animateId);
			controls.reset();

			let loadedState = JSON.parse(file.target.result);

			gui.objectSelect.setValue(loadedState.objectType);

			gui.rotate.setValue(loadedState.rotate);
			gui.rotateX.setValue(loadedState.rotateSpeed.x*loadedState.rotateSpeed.f);
			gui.rotateY.setValue(loadedState.rotateSpeed.y*loadedState.rotateSpeed.f);
			gui.rotateZ.setValue(loadedState.rotateSpeed.z*loadedState.rotateSpeed.f);

			gui.metalness.setValue(loadedState.metalness);
			gui.roughness.setValue(loadedState.roughness);
			gui.transparency.setValue(loadedState.transparency);
			gui.flatShading.setValue(loadedState.flatShading);
			gui.reflectivity.setValue(loadedState.reflectivity);
			gui.clearcoat.setValue(loadedState.clearcoat);
			gui.clearcoatRoughness.setValue(loadedState.clearcoatRoughness);
			switch(loadedState.side){
				case THREE.FrontSide:
					gui.side.setValue("Front");
					break;
				case THREE.BackSide:
					gui.side.setValue("Back");
					break;
				case THREE.DoubleSide:
					gui.side.setValue("Both");
					break;
			};

			gui.setTex.setValue(loadedState.currentTexture);
			gui.background.setValue(loadedState.currentBackground);
			gui.environment.setValue(loadedState.currentEnvironment);
			gui.envMapIntensity.setValue(loadedState.envMapIntensity);

			gui.light1Intensity.setValue(loadedState.lights.light1.intensity);
			gui.light2Intensity.setValue(loadedState.lights.light2.intensity);
			gui.light3Intensity.setValue(loadedState.lights.light3.intensity);
			gui.ambientIntensity.setValue(loadedState.lights.ambient.intensity);
			gui.torchIntensity.setValue(loadedState.lights.torch.intensity);
			gui.useTorch.setValue(loadedState.torchOn);
			gui.fixTorch.setValue(loadedState.fixTorchPosition);
			lights.torch.position.copy(loadedState.lights.torch.position);

			for(const [name, color] of Object.entries(loadedState.colors)){
				if(name.substr(0, 8) == "textured"){
					state.colors[name] = color;
				}
				else{
					setColor(name, color);
				};
			};

			for(const [name, light] of Object.entries(loadedState.lights)){
				setColor(name, light.color);
			};

			let loader = new THREE.ObjectLoader();
			camera.copy(loader.parse(JSON.parse(loadedState.camera.json)));
			parent.rotation.set(loadedState.currentRotation.x, loadedState.currentRotation.y, loadedState.currentRotation.z);

			resizeScreen();

			animate();
		};

		function saveState(){
			for(const [name, light] of Object.entries(lights)){
				state.lights[name] = {color: '#'+light.color.getHexString(), intensity: light.intensity};
			};
			state.lights.torch.position = lights.torch.position;

			state.camera.json = JSON.stringify(camera.toJSON());
			state.currentRotation = {x: parent.rotation.x, y: parent.rotation.y, z: parent.rotation.z};

			download(JSON.stringify(state), "scene.scn", 'text/plain', "saveLink");
		};

		function screenshot(){
			let elt = document.getElementById("saveLink");
			elt.href = renderer.domElement.toDataURL("image/png");
			elt.download = 'screenshot.png';
			elt.click();
			//let win = window.open();
			//document.write('<iframe src="' + renderer.domElement.toDataURL("image/png") + '" frameborder="0" style="margin: 0; padding: 0; border: 0; background-color: white; overflow: hidden; width:100%; height:100%; display:block; line-height: 0; position: absolute; left: 0; top: 0" allowfullscreen></iframe>');
		};

		function exportObject(){
			let exporter = new THREE.GLTFExporter();
			let geometry = object1.geometry.clone();
			let faces = [];

			if(state.crossguard){
				geometry.merge(crossguard1.geometry, new THREE.Matrix4(), 0);
			};

			for(const face of geometry.faces){
				if(face.materialIndex !== 1 && face.materialIndex !== 2){
					faces.push(face);
				};
			};

			geometry.faces = faces;

			let bufferedObject = new THREE.Mesh(new THREE.BufferGeometry().fromGeometry(geometry), object1.material);

			exporter.parse(bufferedObject, function(gltf){
				download(gltf, 'object.glb', 'text/plain', "saveLink");
			}, {binary: true, onlyVisible: true, forceIndices: true});
		};

//SETUP THE CANVAS
		function setCanvas(){
			webGLDiv = document.getElementById("webGLDiv");
			divHeight = webGLDiv.clientHeight;
			divWidth = webGLDiv.clientWidth;

			camera = new THREE.PerspectiveCamera(45, divWidth/ divHeight, 0.1, 1000);

			renderer.setSize(divWidth, divHeight);
			webGLDiv.appendChild(renderer.domElement);
			renderer.physicallyCorrectLights = true;
			renderer.autoClear = false;
		};

//BUILD OBJECTS
		function buildObjects(){
			loadingDiv.innerHTML = 'Building Lightsabers';

			setTimeout(function(){
				object1 = buildLightsaber(1, state.saberlength);
				crossguard1 = buildCrossguard(1, state.saberlength);
				object1.add(crossguard1);
				object1.add(lightning["object1"]);
				crossguard1.add(lightning["crossObject1"]);

				object1.rotateZ(7*Math.PI / 22);
				object1.rotateY(Math.PI / 12);
				object1.rotateX(-1*Math.PI / 36);
				object1.translateOnAxis(new THREE.Vector3(0, 0, 1), 0.11);

				object2 = buildLightsaber(2, state.saberlength);
				crossguard2 = buildCrossguard(2, state.saberlength);
				object2.add(crossguard2);
				object2.add(lightning["object2"]);
				crossguard2.add(lightning["crossObject2"]);

				object2.rotateZ(-7*Math.PI / 22);
				object2.rotateY(-1*Math.PI / 12);
				object2.rotateX(Math.PI / 36);
				object2.translateOnAxis(new THREE.Vector3(0, 0, -1), 0.11);

				hiltMaterial["envMap"] = environments["pluto"];
				hiltTopMaterial["envMap"] = environments["pluto"];

				draw(state.objectType);
				needsRedraw = true;
				loadingDiv.style.display = "none";
			}, 50);
		};

//DRAW THE SCENE ON THE CANVAS
		function go(){
			if(state.shadows){
				renderer.shadowMap.enabled = true;
			};

			makeBackground();
			makeScene();
			lighting();

			makeGUI();

			loadMaps();

			setEnv(state.currentEnvironment);
			setBackground(state.currentBackground);

			mouseControl();
			document.addEventListener("keydown", onDocumentKeyDown, {passive: true});
			webGLDiv.addEventListener('click', () => document.activeElement.blur(), {passive: true});
			fullscreenSetup();
			autoHideCursor();
			animate();
		};

//ON LOAD - MAKE IT SO!!!
		document.addEventListener("DOMContentLoaded", function(event){
			loadingDiv = document.getElementById("loading");
			document.getElementById('fileInput').addEventListener('change', readJSONFile, {passive: true});

			setCanvas();
			go();
		}, {passive: true});

//FULLSCREEN
		function fullscreenSetup(){
			let fullScreenChangeHandler = function(){
				if(document.webkitIsFullScreen || document.mozFullScreen || document.msFullscreenElement){
					state.fullscreen = true;
					gui.gui.hide();
					//document.getElementById("jaznetLink").style.display = "none";
				}
				else{
					state.fullscreen = false;
					gui.gui.show();
					//document.getElementById("jaznetLink").style.display = "block";
				};
			};

			let goFullscreen = function(){
				function launchIntoFullscreen(element){
					if(element.requestFullscreen){
						element.requestFullscreen();
					}
					else if(element.mozRequestFullScreen){
						element.mozRequestFullScreen();
					}
					else if(element.webkitRequestFullscreen){
						element.webkitRequestFullscreen();
					}
					else if(element.msRequestFullscreen){
						element.msRequestFullscreen();
					}
				};

				function exitFullscreen(){
					if(document.exitFullscreen){
						document.exitFullscreen();
					}
					else if(document.mozCancelFullScreen){
						document.mozCancelFullScreen();
					}
					else if(document.webkitExitFullscreen){
						document.webkitExitFullscreen();
					}
				};

				if(!state.fullscreen){
					launchIntoFullscreen(document.documentElement);
				}
				else{
					exitFullscreen();
				};
			};

			if(document.addEventListener){
				document.addEventListener('webkitfullscreenchange', fullScreenChangeHandler, false);
				document.addEventListener('mozfullscreenchange', fullScreenChangeHandler, false);
				document.addEventListener('fullscreenchange', fullScreenChangeHandler, false);
				document.addEventListener('MSFullscreenChange', fullScreenChangeHandler, false);
			};

			webGLDiv.addEventListener("dblclick", goFullscreen, {passive: true});
		};

//HIDE CURSOR
		let autoHideCursor = function(){
			let mouseTimer = null;
			let cursorVisible = true;

			function disappearCursor(){
				mouseTimer = null;
				document.body.style.cursor = "none";
				cursorVisible = false;
			};

			document.onmousemove = function(){
				if(mouseTimer){
					window.clearTimeout(mouseTimer);
				};

				if(!cursorVisible){
					document.body.style.cursor = "default";
					cursorVisible = true;
				}

				mouseTimer = window.setTimeout(disappearCursor, 5000);
			};
		};

//ON WINDOW RESIZE
		function resizeScreen(event){
			divHeight = webGLDiv.clientHeight;
			divWidth = webGLDiv.clientWidth;
			camera.aspect = divWidth/ divHeight;
			camera.updateProjectionMatrix();
			renderer.setSize(divWidth, divHeight);
		};

		window.addEventListener("resize", function(event){resizeScreen(event)}, {passive: true});

//DOWNLOAD
		function download(text, name, type, eltId){
			let elt = document.getElementById(eltId);
			let file = new Blob([text], {type: type});
			elt.href = URL.createObjectURL(file);
			elt.download = name;
			elt.click();
		};
	</script>
</head>

<body>
	<div id="webGLDiv"></div>

	<div id="pickr"></div>

	<div id="loading">
	</div>

	<a id="saveLink" style="display:none"></a>
	<input type="file" id="fileInput" accept=".scn" style="display:none"/>

	<div id="jaznetLink" style="position: absolute; bottom: 10px; right: 10px; display: none">
		<a id="jaznet" href="../index.html">&lt;&lt; Back to Jaznet</a>
	</div>
</body>
</html>